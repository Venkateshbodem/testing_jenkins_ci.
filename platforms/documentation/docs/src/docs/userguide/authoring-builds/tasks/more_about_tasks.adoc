// Copyright (C) 2023 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[more_about_tasks]]
= Authoring Tasks

Gradle supports tasks that have their own properties and methods.
Such tasks are either provided by you or built into Gradle.

[[sec:task_outcomes]]
== Task outcomes

When Gradle executes a task, it labels the task with outcomes via the <<third_party_integration.adoc#embedding,Tooling API>>.

image::author-tasks-1.png[]

These labels are based on whether a task has actions to execute and if Gradle executed them.

`(no label)` or `EXECUTED`:: *Task executed its actions.*
* Task has actions and Gradle executed them.
* Task has no actions and some dependencies, and Gradle executed one or more of the dependencies. See also <<#sec:lifecycle_tasks,Lifecycle Tasks>>.

`UP-TO-DATE`:: *Task's outputs did not change.*
* Task has outputs and inputs but they have not changed. See <<incremental_build.adoc#incremental_build,Incremental Build>>.
* Task has actions, but the task tells Gradle it did not change its outputs.
* Task has no actions and some dependencies, but all the dependencies are `UP-TO-DATE`, `SKIPPED` or `FROM-CACHE`. See <<#sec:lifecycle_tasks,Lifecycle Tasks>>.
* Task has no actions and no dependencies.

`FROM-CACHE`:: *Task's outputs could be found from a previous execution.*
* Task has outputs restored from the build cache. See <<build_cache.adoc#build_cache,Build Cache>>.

`SKIPPED`:: *Task did not execute its actions.*
* Task has been explicitly excluded from the command-line. See <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,Excluding tasks from execution>>.
* Task has an `onlyIf` predicate return false. See <<#sec:using_a_predicate,Using a predicate>>.

`NO-SOURCE`:: *Task did not need to execute its actions.*
* Task has inputs and outputs, but <<incremental_build.adoc#skip-when-empty,no sources>>.

[[sec:defining_tasks]]
== Registering tasks

Tasks are defined using <<tutorial_using_tasks.adoc#tutorial_using_tasks,strings for tasks names>>:

====
include::sample[dir="snippets/tasks/defineUsingStringTaskNames/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/defineUsingStringTaskNames/groovy",files="build.gradle[]"]
====

In the example above, the tasks are added to the `tasks` collection using the `register()` method in link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[TaskContainer].

In the Kotlin DSL there is a specific link:https://kotlinlang.org/docs/reference/delegated-properties.html[delegated properties] syntax useful if you need to register a task for further reference:

====
include::sample[dir="snippets/tasks/defineAsKotlinDelegatedProperty/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/defineAsKotlinDelegatedProperty/groovy",files="build.gradle[]"]
====

[WARNING]
====
If you look at the API of the _tasks_ container you may notice that there are additional methods to _create_ tasks.
The use of these methods is strongly discouraged and will be deprecated in future versions of Gradle.
These methods only exist for backward compatibility.
====

[[sec:locating_tasks]]
== Locating tasks

You may need to locate a task that you have defined in the build file, for example, to configure it or use it for dependencies.
There are a number of ways to do this.

In general, tasks are available through the `tasks` collection.
To ensure that you do not break <<task_configuration_avoidance#task_configuration_avoidance,task configuration avoidance>>, you should use the methods that return a _task provider_:

- `register()`
- `named()`

Here is an example of accessing a task via the `tasks` collection:

====
include::sample[dir="snippets/tasks/accessFromTaskContainer/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/accessFromTaskContainer/groovy",files="build.gradle[]"]
====

Tasks of a specific type can also be accessed using the `tasks.withType()` method.
This avoids duplication of code and minimizes redundancy:

====
include::sample[dir="snippets/tasks/accessUsingType/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/accessUsingType/groovy",files="build.gradle[]"]
====

[[sec:configuring_tasks]]
== Configuring tasks

Let’s look at the `Copy` task provided by Gradle as an example.
To register a `Copy` task for your build, you can declare it in your build script:

====
include::sample[dir="snippets/tasks/configureUsingBlock/kotlin",files="build.gradle.kts[tags=declare-task]"]
include::sample[dir="snippets/tasks/configureUsingBlock/groovy",files="build.gradle[tags=declare-task]"]
====

This registers a copy task with no default behavior.
The name of this task is `myCopy`, but it is of _type_ `Copy`.

As such, the task can be configured using its API (see link:{groovyDslPath}/org.gradle.api.tasks.Copy.html[Copy]).

TIP: You can have multiple tasks of the same _type_, but with different names.

The following examples show several ways to achieve the same configuration.

=== 1. Using the `named()` method:

====
include::sample[dir="snippets/tasks/configureUsingVar/kotlin",files="build.gradle.kts[tags=configure]"]
include::sample[dir="snippets/tasks/configureUsingVar/groovy",files="build.gradle[tags=configure]"]
====

=== 2. Using the task reference:

====
include::sample[dir="snippets/tasks/configureUsingBlock/kotlin",files="build.gradle.kts[tags=configure]"]
include::sample[dir="snippets/tasks/configureUsingBlock/groovy",files="build.gradle[tags=configure]"]
====

=== 3. Using a configuration block:

====
include::sample[dir="snippets/tasks/defineAndConfigure/kotlin",files="build.gradle.kts[tags=no-description]"]
include::sample[dir="snippets/tasks/defineAndConfigure/groovy",files="build.gradle[tags=no-description]"]
====

A task has both _configuration_ and _action_.

When using `doLast`, you are simply using a shortcut to define an _action_.
Code defined in the configuration section of your task will get executed during the <<build_lifecycle.adoc#build_lifecycle,_configuration phase_ of the build>> regardless of what task was targeted.

====
include::sample[dir="snippets/files/archiveNaming/kotlin",files="build.gradle.kts[tags=zip-task-with-custom-base-name]"]
include::sample[dir="snippets/files/archiveNaming/groovy",files="build.gradle[tags=zip-task-with-custom-base-name]"]
====

The `myCustomZip` task will ZIP the files in the _configuration phase_ and the name of the archive will be printed in the _execution phase_.

[[sec:passing_arguments_to_a_task_constructor]]
== Passing arguments

As opposed to configuring the mutable properties of a `Task` after creation, you can pass argument values to the `Task` class's constructor.

In order to pass values to the `Task` constructor, you must annotate the relevant constructor with `@javax.inject.Inject`:

====
include::sample[dir="snippets/tasks/taskConstructorArgs-onTaskContainer/kotlin",files="build.gradle.kts[tags=inject-task-constructor]"]
include::sample[dir="snippets/tasks/taskConstructorArgs-onTaskContainer/groovy",files="build.gradle[tags=inject-task-constructor]"]
====

Then, you can create a task by passing the constructor arguments at the end of the parameter list:

====
include::sample[dir="snippets/tasks/taskConstructorArgs-onTaskContainer/kotlin",files="build.gradle.kts[tags=on-task-container]"]
include::sample[dir="snippets/tasks/taskConstructorArgs-onTaskContainer/groovy",files="build.gradle[tags=on-task-container]"]
====

The values passed as constructor arguments must be non-null.
If you attempt to pass a `null` value, Gradle will throw a `NullPointerException` indicating which runtime value is `null`.

TIP: The <<task_configuration_avoidance.adoc#task_configuration_avoidance,Task Configuration Avoidance>> APIs are recommended as they improve configuration time.

[[sec:adding_dependencies_to_tasks]]
== Adding dependencies

There are several ways you can define the dependencies of a task.

Defining dependencies using task names is the simplest way.
Task names can refer to tasks in the same project as the task, or to tasks in other projects.

To refer to a task in another project, you prefix the name of the task with the path of the project it belongs to.

The following is an example which adds a dependency from `project-a:taskX` to `project-b:taskY`:

====
include::sample[dir="snippets/tasks/addDependencyUsingPath/kotlin",files="project-a/build.gradle.kts[];project-b/build.gradle.kts[]"]
include::sample[dir="snippets/tasks/addDependencyUsingPath/groovy",files="project-a/build.gradle[];project-b/build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tasks/addDependencyUsingPath/tests/addDependencyUsingPath.out[]
----
====

Instead of using a task name, you can define a dependency using a `TaskProvider` object:

====
include::sample[dir="snippets/tasks/addDependencyUsingTask/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/addDependencyUsingTask/groovy",files="build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tasks/addDependencyUsingTask/tests/addDependencyUsingTask.out[]
----
====

You can also define a task dependency using a lazy block.

When evaluated, the block is passed the task whose dependencies are being determined.
The lazy block should return a single `Task` or collection of `Task` objects, which are then treated as dependencies of the task.

The following example adds a dependency from `taskX` to all the tasks in the project whose name starts with `lib`:

====
include::sample[dir="snippets/tasks/addDependencyUsingClosure/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/addDependencyUsingClosure/groovy",files="build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tasks/addDependencyUsingClosure/tests/addDependencyUsingClosure.out[]
----
====

For more information about task dependencies, see the link:{groovyDslPath}/org.gradle.api.Task.html[Task] API.

[[sec:ordering_tasks]]
== Ordering tasks

In some cases it is useful to control the _order_ in which two tasks will execute, without introducing an explicit dependency between those tasks.

The primary difference between a task _ordering_ and a task _dependency_ is that an ordering rule does not influence which tasks will be executed, only the order in which they will be executed.

Task ordering can be useful in a number of scenarios:

* Enforce sequential ordering of tasks: e.g. 'build' never runs before 'clean'.
* Run build validations early in the build: e.g. validate I have the correct credentials before starting the work for a release build.
* Get feedback faster by running quick verification tasks before long verification tasks: e.g. unit tests should run before integration tests.
* A task that aggregates the results of all tasks of a particular type: e.g. test report task combines the outputs of all executed test tasks.

There are two ordering rules available: “_must run after_” and “_should run after_”.

When you use “must run after”, you specify that `taskB` must always run after `taskA` when the build requires the execution of `taskA` and `taskB`.
This is expressed as `taskB.mustRunAfter(taskA)`.

====
include::sample[dir="snippets/tasks/mustRunAfter/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/mustRunAfter/groovy",files="build.gradle[]"]

----
$ gradle -q taskY taskX
include::{snippetsPath}/tasks/mustRunAfter/tests/mustRunAfter.out[]
----
====

The “should run after” ordering rule is similar but less strict as it will be ignored in two situations:

1. If using that rule introduces an ordering cycle.
2. When using parallel execution and all dependencies of a task have been satisfied apart from the “should run after” task, then this task will be run regardless of whether its “should run after” dependencies have been run or not.

You should use “should run after” where the ordering is helpful but not strictly required:

====
include::sample[dir="snippets/tasks/shouldRunAfter/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/shouldRunAfter/groovy",files="build.gradle[]"]

----
$ gradle -q taskY taskX
include::{snippetsPath}/tasks/shouldRunAfter/tests/shouldRunAfter.out[]
----
====

With these rules present it is still possible to execute `taskA` without `taskB` and vice-versa.

In the examples above, it is still possible to execute `taskY` without causing `taskX` to run:

====
----
$ gradle -q taskY
include::{snippetsPath}/tasks/mustRunAfter/tests/mustRunAfterSingleTask.out[]
----
====

To specify a “must run after” or “should run after” ordering between 2 tasks, you use the link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object++[]++)[Task.mustRunAfter(java.lang.Object++...++)] and link:{javadocPath}/org/gradle/api/Task.html#shouldRunAfter-java.lang.Object++...++-[Task.shouldRunAfter(java.lang.Object++...++)] methods.
These methods accept a task instance, a task name, or any other input accepted by link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(java.lang.Object++...++)].

Note that “`B.mustRunAfter(A)`” or “`B.shouldRunAfter(A)`” does not imply any execution dependency between the tasks:

* It is possible to execute tasks `A` and `B` independently. The ordering rule only has an effect when both tasks are scheduled for execution.
* When run with `--continue`, it is possible for `B` to execute in the event that `A` fails.

The “should run after” ordering rule will be ignored if it introduces an ordering cycle:

====
include::sample[dir="snippets/tasks/shouldRunAfterWithCycle/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/shouldRunAfterWithCycle/groovy",files="build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tasks/shouldRunAfterWithCycle/tests/shouldRunAfterWithCycle.out[]
----
====

[[sec:adding_a_description_to_a_task]]
== Adding a description or group

You can add a description to your task and assign it to a group:

====
include::sample[dir="snippets/tasks/defineAndConfigure/kotlin",files="build.gradle.kts[tags=all]"]
include::sample[dir="snippets/tasks/defineAndConfigure/groovy",files="build.gradle[tags=all]"]
====

This name and description is displayed under its assigned group when executing `gradle tasks`:

[source]
----
$ ./gradlew tasks

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project 'lab'
------------------------------------------------------------

Help tasks
----------
copy - Copies the resource directory to the target directory.
----

[[sec:skipping_tasks]]
== Skipping tasks

Gradle offers multiple ways to skip the execution of a task.

[[sec:using_a_predicate]]
=== 1. Using a predicate

You can use link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)[`Task.onlyIf`] to attach a predicate to a task.
The task's actions will only be executed if the predicate evaluates to `true`.

The predicate is passed to the task as a parameter and returns `true` if the task will execute and `false` if the task will be skipped.
The predicate is evaluated just before the task is executed.

Passing an optional reason string to `onlyIf()` is useful for explaining why the task is skipped:

====
include::sample[dir="snippets/tutorial/taskOnlyIf/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/taskOnlyIf/groovy",files="build.gradle[]"]

----
$ gradle hello -PskipHello
include::{snippetsPath}/tutorial/taskOnlyIf/tests/taskOnlyIf.out[]
----
====

To find the reason a task was skipped, run the build with the `--info` logging level.

====
----
$ gradle hello -PskipHello --info
include::{snippetsPath}/tutorial/taskOnlyIf/tests/taskOnlyIf-info.out[]
----
====

[[sec:using_stopexecutionexception]]
=== 2. Using StopExecutionException

If the logic for skipping a task can't be expressed with a predicate, you can use the link:{javadocPath}/org/gradle/api/tasks/StopExecutionException.html[`StopExecutionException`].

If this exception is thrown by an action, the task action as well as the execution of any following action is skipped.
The build continues by executing the next task:

====
include::sample[dir="snippets/tutorial/stopExecutionException/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/stopExecutionException/groovy",files="build.gradle[]"]

----
$ gradle -q myTask
include::{snippetsPath}/tutorial/stopExecutionException/tests/stopExecutionException.out[]
----
====

This feature is helpful if you work with tasks provided by Gradle.
It allows you to add _conditional_ execution of the built-in actions of such a task.footnote:[You might be wondering why there is neither an import for the `StopExecutionException` nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports to your script (see <<writing_build_scripts.adoc#script-default-imports,Default imports>>).]

[[sec:enabling_and_disabling_tasks]]
=== 3. Enabling and Disabling tasks

Every task has an `enabled` flag which defaults to `true`.
Setting it to `false` prevents the execution of the task's actions.

A disabled task will be labelled `SKIPPED`:

====
include::sample[dir="snippets/tutorial/disableTask/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/disableTask/groovy",files="build.gradle[]"]

----
$ gradle disableMe
include::{snippetsPath}/tutorial/disableTask/tests/disableTask.out[]
----
====

[[sec:task_timeouts]]
=== 4. Task timeouts

Every task has a `timeout` property which can be used to limit its execution time.
When a task reaches its timeout, its task execution thread is interrupted.
The task will be marked as `FAILED`.

Finalizer tasks are executed.
If `--continue` is used, other tasks continue running.

Tasks that don't respond to interrupts can't be timed out.
All of Gradle's built-in tasks respond to timeouts.

====
include::sample[dir="snippets/tasks/timeout/kotlin",files="build.gradle.kts[tags=without-import]"]
include::sample[dir="snippets/tasks/timeout/groovy",files="build.gradle[]"]
====

[[sec:task_rules]]
== Task rules

Sometimes you want to have a task whose behavior depends on a large or infinite number value range of parameters.

An expressive way to provide such tasks are task rules:

====
include::sample[dir="snippets/tasks/addRules/kotlin",files="build.gradle.kts[tags=task-rule]"]
include::sample[dir="snippets/tasks/addRules/groovy",files="build.gradle[tags=task-rule]"]

----
$ gradle -q pingServer1
include::{snippetsPath}/tasks/addRules/tests/taskRule.out[]
----
====

The `String` parameter is used as a description for the rule, which is shown with `gradle tasks`.

Rules are not only used when calling tasks from the command line.
You can also create `dependsOn` relations with rule based tasks:

====
include::sample[dir="snippets/tasks/addRules/kotlin",files="build.gradle.kts[tags=all]"]
include::sample[dir="snippets/tasks/addRules/groovy",files="build.gradle[tags=all]"]

----
$ gradle -q groupPing
include::{snippetsPath}/tasks/addRules/tests/taskRuleDependsOn.out[]
----
====

If you run `gradle -q tasks` you won't find a task named `pingServer1` or `pingServer2`, but this script is executing logic based on the request to run those tasks.

[[sec:finalizer_tasks]]
== Finalizer tasks

Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run:

====
include::sample[dir="snippets/tasks/finalizers/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/finalizers/groovy",files="build.gradle[]"]

.Output of **`gradle -q taskX`**
----
> gradle -q taskX
include::{snippetsPath}/tasks/finalizers/tests/taskFinalizers.out[]
----
====

Finalizer tasks will be executed even if the finalized task fails or if the finalized task is considered up to date:

====
include::sample[dir="snippets/tasks/finalizersWithFailure/kotlin",files="build.gradle.kts[]"]
include::sample[dir="snippets/tasks/finalizersWithFailure/groovy",files="build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tasks/finalizersWithFailure/tests-groovy/taskFinalizersWithFailureGroovy.out[]
----
====

Finalizer tasks are useful in situations where the build creates a resource that has to be cleaned up regardless of the build failing or succeeding.
An example of such a resource is a web container that is started before an integration test task and must be shut down, even if some of the tests fail.

To specify a finalizer task you use the link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object++[]++)[Task.finalizedBy(java.lang.Object...)] method.
This method accepts a task instance, a task name, or any other input accepted by link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(java.lang.Object...)].

[[sec:lifecycle_tasks]]
== Lifecycle tasks

Lifecycle tasks are tasks that do not do work themselves.
They typically do not have any task actions.

Lifecycle tasks can represent several concepts:

* a work-flow step (e.g., run all checks with `check`)
* a buildable thing (e.g., create a debug 32-bit executable for native components with `debug32MainExecutable`)
* a convenience task to execute many of the same logical tasks (e.g., run all compilation tasks with `compileAll`)

The Base Plugin defines several <<base_plugin#sec:base_tasks,standard lifecycle tasks>>, such as `build`, `assemble`, and `check`.
All the core language plugins, like the <<java_plugin#java_plugin,Java Plugin>>, apply the Base Plugin and hence have the same base set of lifecycle tasks.

Unless a lifecycle task has actions, its <<#sec:task_outcomes,outcome>> is determined by its task dependencies.
If any of those dependencies are executed, the lifecycle task will be considered `EXECUTED`.
If all the task dependencies are `UP-TO-DATE`, `SKIPPED` or `FROM-CACHE` the lifecycle task will be considered `UP-TO-DATE`.

[[sec:the_idea_behind_gradle_tasks]]
[[sec:more_up_to_date_checks]]
[[sec:more_task_inputs_outputs]]
[[sec:more_task_input_output_annotations]]
[[sec:more_task_input_using_dependency_resolution_results]]
[[sec:more_task_input_using_classpath_annotations]]
[[sec:more_task_input_nested_inputs]]
[[sec:more_task_input_validation]]
[[sec:more_task_input_output_runtime_api]]
[[sec:more_runtime_api_for_adhoc]]
[[sec:more_runtime_api_configuration]]
[[sec:more_runtime_api_for_custom_tasks]]
[[sec:more_task_input_output_side_effects]]
[[sec:more_inferred_task_dependencies]]
[[sec:more_task_input_output_validation]]
[[sec:more_task_input_output_continuous_build]]
[[sec:more_task_input_output_parallelism]]
[[sec:more_how_does_it_work]]
[[sec:more_advanced_inc_build]]
[[sec:more_add_cached_input_output_methods]]
[[sec:more_link_output_dir_to_input_files]]
[[sec:more_disable-state-tracking]]
[[sec:more_untracked_external_tool]]
[[sec:more_configure_input_normalization]]
[[sec:more_property_file_normalization]]
[[sec:more_meta_inf_normalization]]
[[sec:more_custom_up_to_date_logic]]
[[sec:more_stale_task_outputs]]
