// This is sort of a hack
// 1. It will make most of gradle compile in eclipse
// 2. It requires some adjustments in eclipse to work properly - see below
//
// Things required for this hack to work:
//  1. Eclipse must be a recent one and needs the Groovyclipse feature. Take it from here, for example http://dist.springsource.org/snapshot/GRECLIPSE/e4.4/
//  2. 2GB of memory is required (Add or alter -Xmx2g to eclipse.ini)
//  3. The complete gradle project from github must be cloned (i.e. https://github.com/gradle/gradle)
//  5. Run ./gradlew build on that folder
//  6. Run ./gradlew eclipse on that folder
//  7. Configure a JRE in Eclipse which is at least 1.7. Set the JRE name property of that JRE to 'JavaSE-1.5'
//  8. In Window->Preferences->Groovy->Compiler, check 'Enable Script folder support' and Add '**/*.gradle'
//  9. Import the gradle project into the Eclipse workspace, choose 'search for nested projects', take ALL projects
// 10. Wait 5 minutes for Eclipse to calm down
// 11. Accept that some things just don't seem to work in Eclipse, especially some of the groovy files

import org.gradle.util.GUtil

def subprojectsPath = new File(projectDir,'/subprojects').absolutePath

apply plugin: 'eclipse'

eclipse.project.file.withXml {
	def prj = it.asNode()

	// remove all natures and buildspec from the root project - otherwise the groovy files will be compiled twice in Eclipse
	prj.remove prj.natures
	prj.remove prj.buildSpec

}

subprojects { subProject ->
	subProject.apply plugin: 'eclipse'

	subProject.plugins.withType(JavaPlugin) {
		eclipse {
			classpath {
				file.whenMerged { classpath ->
					//There are classes in here not designed to be compiled, but just used in our testing
					classpath.entries.removeAll { it.path.contains('src/integTest/resources') }
					//Workaround for some projects referring to themselves as dependent projects
					classpath.entries.removeAll { it.path.contains("$project.name") && it.kind=='src' }
					classpath.entries.removeAll { it.path.contains("$project.name/build") && it.kind=='lib' }
				}
				file.withXml {
					// postprocessing the xml, because I don't know how to change the sourcepath on the classpathEntry domain object
					Set allEntries = new HashSet();
					def cp = it.asNode()
					cp.classpathentry.each { cpe ->
						if(cpe.@kind == 'lib' ) {
							def originalPath = cpe.@path
							if(originalPath.startsWith(subprojectsPath)){
								String newpath = originalPath.substring(subprojectsPath.length())
								int secondSlashIndex = newpath.indexOf('/', 1)
								if(secondSlashIndex>-1) {
									newpath = newpath.substring(0, secondSlashIndex)
								}
								cpe.@path = '/' + GUtil.toLowerCamelCase(newpath)
								cpe.@kind = 'src'
							}
						}
						if(cpe.@kind == 'src' && cpe.@path.startsWith("/$project.name")) {
							// remove reference to own project
							cp.remove cpe
						} else if(!allEntries.add(cpe.@kind + ':' + cpe.@path)){
							// remove duplicate entry
							cp.remove cpe
						}
					}
				}
			}
			jdt {
				sourceCompatibility = 1.6
				targetCompatibility = 1.6
				file.withProperties { properties ->
					// Eclipse's view of projects treat circular dependencies as errors by default
					properties["org.eclipse.jdt.core.circularClasspath"] = "warning"
				}
			}
		}
	}
}
