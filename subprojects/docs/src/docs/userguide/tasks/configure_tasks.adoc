// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[lazy_configuration]]
= Configure Tasks

As a build grows in complexity, knowing when and where a particular value is configured can become difficult to reason about. Gradle provides several ways to manage this complexity using _lazy configuration_.

[[lazy_properties]]
== Lazy properties

Gradle provides lazy properties, which delay the calculation of a property’s value until it’s actually required. These provide three main benefits to build script and plugin authors:

1. Build authors can wire together Gradle models without worrying when a particular property’s value will be known. For example, you may want to set the input source files of a task based on the source directories property of an extension but the extension property value isn't known until the build script or some other plugin configures them.
2. Build authors can wire an output property of a task into an input property of some other task and Gradle automatically determines the task dependencies based on this connection. Property instances carry information about which task, if any, produces their value. Build authors do not need to worry about keeping task dependencies in sync with configuration changes.
3. Build authors can avoid resource intensive work during the configuration phase, which can have a large impact on build performance. For example, when a configuration value comes from parsing a file but is only used when functional tests are run, using a property instance to capture this means that the file is parsed only when the functional tests are run, but not when, for example, `clean` is run.

Gradle represents lazy properties with two interfaces:

* link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] represents a value that can only be queried and cannot be changed.
** Properties with these types are read-only.
** The method link:{javadocPath}/org/gradle/api/provider/Provider.html#get--[Provider.get()] returns the current value of the property.
** A `Provider` can be created from another `Provider` using link:{javadocPath}/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-[Provider.map(Transformer)].
** Many other types extend `Provider` and can be used where-ever a `Provider` is required.

* link:{javadocPath}/org/gradle/api/provider/Property.html[Property] represents a value that can be queried and also changed.
** Properties with these types are configurable.
** `Property` extends the `Provider` interface.
** The method link:{javadocPath}/org/gradle/api/provider/Property.html#set-T-[Property.set(T)] specifies a value for the property, overwriting whatever value may have been present.
** The method link:{javadocPath}/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-[Property.set(Provider)] specifies a `Provider` for the value for the property, overwriting whatever value may have been present. This allows you to wire together `Provider` and `Property` instances before the values are configured.
** A `Property` can be created by the factory method link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-[ObjectFactory.property(Class)].

Lazy properties are intended to be passed around and only queried when required. Usually, this will happen during the execution phase. For more information about the Gradle build phases, please see <<build_lifecycle.adoc#sec:build_phases,Build Lifecycle>>.

The following demonstrates a task with a configurable `greeting` property and a read-only `message` property that is derived from this:

.Using a read-only and configurable property
====
include::sample[dir="snippets/providers/propertyAndProvider/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/propertyAndProvider/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle greeting`**
----
$ gradle greeting
include::{snippetsPath}/providers/propertyAndProvider/tests/usePropertyAndProvider.out[]
----

The `Greeting` task has a property of type `Property<String>` to represent the configurable greeting and a property of type `Provider<String>` to represent the calculated, read-only, message. The message `Provider` is created from the greeting `Property` using the `map()` method, and so its value is kept up-to-date as the value of the greeting property changes.

[NOTE]
====

Note that Gradle Groovy DSL generates setter methods for each `Property`-typed property in a task implementation. These setter methods allow you to configure the property using the assignment (`=`) operator as a convenience.

In Kotlin DSL, the `set()` method on the property needs to be used instead of `=`.

====

[[creating_property_provider]]
== Creating a Property or Provider instance

Neither `Provider` nor its subtypes such as `Property` are intended to be implemented by a build script or plugin author.  Gradle provides factory methods to create instances of these types instead. See the <<#lazy_configuration_reference,Quick Reference>> for all of the types and factories available. In the previous example, we have seen 2 factory methods:

- link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-[ObjectFactory.property(Class)] create a new `Property` instance. An instance of the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html[ObjectFactory] can be referenced from link:{javadocPath}/org/gradle/api/Project.html#getObjects--[Project.getObjects()] or by injecting `ObjectFactory` through a constructor or method.
- link:{javadocPath}/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-[Provider.map(Transformer)] creates a new `Provider` from an existing `Provider` or `Property` instance.

A `Provider` can also be created by the factory method link:{javadocPath}/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-[ProviderFactory.provider(Callable)]. You should prefer using `map()` instead, as this has some useful benefits, which we will see later.

[NOTE]
====

There are no specific methods create a provider using a `groovy.lang.Closure`. When writing a plugin or build script with Groovy, you can use the `map(Transformer)` method with a closure and Groovy will take care of converting the closure to a `Transformer`. You can see this in action in the previous example.

Similarly, when writing a plugin or build script with Kotlin, the Kotlin compiler will take care of converting a Kotlin function into a `Transformer`.

====

[[connecting_properties_together]]
== Connecting properties together

An important feature of lazy properties is that they can be connected together so that changes to one property are automatically reflected in other properties. Here's an example where the property of a task is connected to a property of a project extension:

.Connecting properties together
====
include::sample[dir="snippets/providers/connectProperties/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/connectProperties/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle greeting`**
----
$ gradle greeting
include::{snippetsPath}/providers/connectProperties/tests/connectProperties.out[]
----

This example calls the link:{javadocPath}/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-[Property.set(Provider)] method to attach a `Provider` to a `Property` to supply the value of the property. In this case, the `Provider` happens to be a `Property` as well, but you can connect any `Provider` implementation, for example one created using `Provider.map()`

[[working_with_files_in_lazy_properties]]
== Working with files

In <<working_with_files.adoc#working_with_files,Working with Files>>, we introduced four collection types for `File`-like objects:

.Collection of files recap
[%header%autowidth,compact]
|===
| Read-only Type | Configurable Type

| link:{javadocPath}/org/gradle/api/file/FileCollection.html[FileCollection]
| link:{javadocPath}/org/gradle/api/file/ConfigurableFileCollection.html[ConfigurableFileCollection]

| link:{javadocPath}/org/gradle/api/file/FileTree.html[FileTree]
| link:{javadocPath}/org/gradle/api/file/ConfigurableFileTree.html[ConfigurableFileTree]
|===

All of these types are also considered lazy types.

In this section, we are going to introduce more strongly typed models types to represent elements of the file system: link:{javadocPath}/org/gradle/api/file/Directory.html[Directory] and link:{javadocPath}/org/gradle/api/file/RegularFile.html[RegularFile]. These types shouldn't be confused with the standard Java link:{javaApi}/java/io/File.html[File] type as they are used to tell Gradle, and other people, that you expect more specific values such as a directory or a non-directory, regular file.

Gradle provides two specialized `Property` subtypes for dealing with values of these types: link:{javadocPath}/org/gradle/api/file/RegularFileProperty.html[RegularFileProperty] and link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html[DirectoryProperty]. link:{javadocPath}/org/gradle/api/model/ObjectFactory.html[ObjectFactory] has methods to create these: link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#fileProperty--[ObjectFactory.fileProperty()] and link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#directoryProperty--[ObjectFactory.directoryProperty()].

A `DirectoryProperty` can also be used to create a lazily evaluated `Provider` for a `Directory` and `RegularFile` via link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-[DirectoryProperty.dir(String)] and link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-[DirectoryProperty.file(String)] respectively. These methods create providers whose values are calculated relative to the location for the `DirectoryProperty` they were created from. The values returned from these providers will reflect changes to the `DirectoryProperty`.

.Using file and directory property
====
include::sample[dir="snippets/providers/fileAndDirectoryProperty/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/fileAndDirectoryProperty/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle generate`**
[.multi-language-text.lang-groovy]
----
$ gradle generate
include::{snippetsPath}/providers/fileAndDirectoryProperty/tests/workingWithFilesGroovy.out[]
----
.Output of **`gradle generate`**
[.multi-language-text.lang-kotlin]
----
$ gradle generate
include::{snippetsPath}/providers/fileAndDirectoryProperty/tests/workingWithFilesKotlin.out[]
----

This example creates providers that represent locations in the project and build directories through link:{javadocPath}/org/gradle/api/Project.html#getLayout--[Project.getLayout()] with link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#getBuildDirectory--[ProjectLayout.getBuildDirectory()] and link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#getProjectDirectory--[ProjectLayout.getProjectDirectory()].

To close the loop, note that a `DirectoryProperty`, or a simple `Directory`, can be turned into a `FileTree` that allows the files and directories contained in the directory to be queried with link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--[DirectoryProperty.getAsFileTree()] or link:{javadocPath}/org/gradle/api/file/Directory.html#getAsFileTree--[Directory.getAsFileTree()]. Moreover, from a `DirectoryProperty`, or a `Directory`, you can also create `FileCollection` instances containing a set of the files contained in the directory with link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#files-java.lang.Object++...++-[DirectoryProperty.files(Object++...++)] or link:{javadocPath}/org/gradle/api/file/Directory.html#files-java.lang.Object++...++-[Directory.files(Object++...++)].

[[working_with_task_dependencies_in_lazy_properties]]
== Working with task inputs and outputs

Many builds have several tasks connected together, where one task consumes the outputs of another task as an input. To make this work, we would need to configure each task to know where to look for its inputs and place its outputs, make sure that the producing and consuming tasks are configured with the same location, and attach task dependencies between the tasks. This can be cumbersome and brittle if any of these values are configurable by a user or configured by multiple plugins, as task properties need to be configured in the correct order and locations and task dependencies kept in sync as values change.

The `Property` API makes this easier by keeping track of not just the value for a property, which we have seen already, but also the task that produces the value, so that you don't have to specify it as well. As an example consider the following plugin with a producer and consumer task which are wired together:

.Implicit task input file dependency
====
include::sample[dir="snippets/providers/implicitTaskInputFileDependency/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/implicitTaskInputFileDependency/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle consumer`**
[.multi-language-text.lang-groovy]
----
$ gradle consumer
include::{snippetsPath}/providers/implicitTaskInputFileDependency/tests/implicitTaskInputFileDependencyGroovy.out[]
----
.Output of **`gradle consumer`**
[.multi-language-text.lang-kotlin]
----
$ gradle consumer
include::{snippetsPath}/providers/implicitTaskInputFileDependency/tests/implicitTaskInputFileDependencyKotlin.out[]
----

In the example above, the task outputs and inputs are connected before any location is defined. The setters can be called at any time before the task is executed and the change will automatically affect all related input and output properties.

Another important thing to note in this example is the absence of any explicit task dependency. Task outputs represented using `Providers` keep track of which task produces their value, and using them as task inputs will implicitly add the correct task dependencies.

Implicit task dependencies also works for input properties that are not files.

.Implicit task input dependency
====
include::sample[dir="snippets/providers/implicitTaskInputDependency/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/implicitTaskInputDependency/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle consumer`**
[.multi-language-text.lang-groovy]
----
$ gradle consumer
include::{snippetsPath}/providers/implicitTaskInputDependency/tests/implicitTaskInputDependencyGroovy.out[]
----
.Output of **`gradle consumer`**
[.multi-language-text.lang-kotlin]
----
$ gradle consumer
include::{snippetsPath}/providers/implicitTaskInputDependency/tests/implicitTaskInputDependencyKotlin.out[]
----

[[working_with_collections]]
== Working with collections

Gradle provides two lazy property types to help configure `Collection` properties. These work exactly like any other `Provider` and, just like file providers, they have additional modeling around them:

* For `List` values the interface is called link:{javadocPath}/org/gradle/api/provider/ListProperty.html[ListProperty]. You can create a new `ListProperty` using link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-[ObjectFactory.listProperty(Class)] and specifying the element type.
* For `Set` values the interface is called link:{javadocPath}/org/gradle/api/provider/SetProperty.html[SetProperty]. You can create a new `SetProperty` using link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-[ObjectFactory.setProperty(Class)] and specifying the element type.

This type of property allows you to overwrite the entire collection value with link:{javadocPath}/org/gradle/api/provider/HasMultipleValues.html#set-java.lang.Iterable-[HasMultipleValues.set(Iterable)] and link:{javadocPath}/org/gradle/api/provider/HasMultipleValues.html#set-org.gradle.api.provider.Provider-[HasMultipleValues.set(Provider)] or add new elements through the various `add` methods:

* link:{javadocPath}/org/gradle/api/provider/HasMultipleValues.html#add-T-[HasMultipleValues.add(T)]: Add a single element to the collection
* link:{javadocPath}/org/gradle/api/provider/HasMultipleValues.html#add-org.gradle.api.provider.Provider-[HasMultipleValues.add(Provider)]: Add a lazily calculated element to the collection
* link:{javadocPath}/org/gradle/api/provider/HasMultipleValues.html#addAll-org.gradle.api.provider.Provider-[HasMultipleValues.addAll(Provider)]: Add a lazily calculated collection of elements to the list

Just like every `Provider`, the collection is calculated when link:{javadocPath}/org/gradle/api/provider/Provider.html#get--[Provider.get()] is called. The following example shows the link:{javadocPath}/org/gradle/api/provider/ListProperty.html[ListProperty] in action:

.List property
====
include::sample[dir="snippets/providers/listProperty/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/listProperty/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle consumer`**
[.multi-language-text.lang-groovy]
----
$ gradle consumer
include::{snippetsPath}/providers/listProperty/tests/listPropertyGroovy.out[]
----
.Output of **`gradle consumer`**
[.multi-language-text.lang-kotlin]
----
$ gradle consumer
include::{snippetsPath}/providers/listProperty/tests/listPropertyKotlin.out[]
----

[[working_with_maps]]
== Working with maps

Gradle provides a lazy link:{javadocPath}/org/gradle/api/provider/MapProperty.html[MapProperty] type to allow `Map` values to be configured.
You can create a `MapProperty` instance using link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#mapProperty-java.lang.Class-java.lang.Class-[ObjectFactory.mapProperty(Class, Class)].

Similar to other property types, a `MapProperty` has a link:{javadocPath}/org/gradle/api/provider/MapProperty.html#set-java.util.Map-[set()] method that you can use to specify the value for the property. There are some additional methods to allow entries with lazy values to be added to the map.

.Map property
====
include::sample[dir="snippets/providers/mapProperty/groovy",files="build.gradle[]"]
include::sample[dir="snippets/providers/mapProperty/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle consumer`**
----
$ gradle generate
include::{snippetsPath}/providers/mapProperty/tests/mapProperty.out[]
----

[[applying_conventions]]
== Applying a convention to a property

Often you want to apply some _convention_, or default value, to a property to be used if no value has been configured for the property. You can use the `convention()` method for this. This method accepts either a value or a `Provider` and this will be used as the value until some other value is configured.

.Property conventions
====
include::sample[dir="snippets/providers/propertyConvention/groovy",files="build.gradle[tags=conventions]"]
include::sample[dir="snippets/providers/propertyConvention/kotlin",files="build.gradle.kts[tags=conventions]"]
====

.Output of **`gradle show`**
----
$ gradle show
include::{snippetsPath}/providers/propertyConvention/tests/propertyConvention.out[]
----

[[unmodifiable_property]]
== Making a property unmodifiable

Most properties of a task or project are intended to be configured by plugins or build scripts and then the resulting value used to do something useful. For example, a property that specifies the output directory for a compilation task may start off with a value specified by a plugin, then a build script might change the value to some custom location, then this value is used by the task when it runs.
However, once the task starts to run, we want to prevent any further change to the property. This way we avoid errors that result from different consumers, such as the task action or Gradle's up-to-date checks or build caching or other tasks, using different values for the property.

Lazy properties provide several methods that you can use to disallow changes to their value once the value has been configured.
The link:{javadocPath}/org/gradle/api/provider/Property.html#finalizeValue--[finalizeValue()] method calculates the _final_ value for the property and prevents further changes to the property.
When the value of the property comes from a `Provider`, the provider is queried for its current value and the result becomes the final value for the property.
This final value replaces the provider and the property no longer tracks the value of the provider.
Calling this method also makes a property instance unmodifiable and any further attempts to change the value of the property will fail.
Gradle automatically makes the properties of a task final when the task starts execution.

The link:{javadocPath}/org/gradle/api/provider/HasConfigurableValue.html#finalizeValueOnRead--[finalizeValueOnRead()] method is similar, except that the property's final value is not calculated until the value
of the property is queried. In other words, this method calculates the final value lazily as required, whereas `finalizeValue()` calculates the final value eagerly.
This method can be used when the value may be expensive to calculate or may not have been configured yet, but you also want to ensure that all consumers of the property see the same value when they query the value.

[[lazy_configuration_faqs]]
== Guidelines

This section will introduce guidelines to be successful with the Provider API. To see those guidelines in action, have a look at https://github.com/gradle/gradle-site-plugin[gradle-site-plugin], a Gradle plugin demonstrating established techniques and practices for plugin development.

* The link:{javadocPath}/org/gradle/api/provider/Property.html[Property] and link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] types have all of the overloads you need to query or configure a value. For this reason, you should follow the following guidelines:
** For configurable properties, expose the link:{javadocPath}/org/gradle/api/provider/Property.html[Property] directly through a single getter.
** For non-configurable properties, expose an link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] directly through a single getter.
* Avoid simplifying calls like `obj.getProperty().get()` and `obj.getProperty().set(T)` in your code by introducing additional getters and setters.
* When migrating your plugin to use providers, follow these guidelines:
** If it's a new property, expose it as a link:{javadocPath}/org/gradle/api/provider/Property.html[Property] or link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] using a single getter.
** If it's incubating, change it to use a link:{javadocPath}/org/gradle/api/provider/Property.html[Property] or link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] using a single getter.
** If it's a stable property, add a new link:{javadocPath}/org/gradle/api/provider/Property.html[Property] or link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider] and deprecate the old one. You should wire the old getter/setters into the new property as appropriate.

[[lazy_configuration_roadmap]]
== Future development

Going forward, new properties will use the Provider API. The Groovy Gradle DSL adds convenience methods to make the use of Providers mostly transparent in build scripts. Existing tasks will have their existing "raw" properties replaced by Providers as needed and in a backwards compatible way. New tasks will be designed with the Provider API.

[[lazy_configuration_reference]]
== Provider Files API Reference

Use these types for _read-only_ values:

link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider]<link:{javadocPath}/org/gradle/api/file/RegularFile.html[RegularFile]>:: File on disk
  Factories;;
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-[Provider.map(Transformer)].
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-[Provider.flatMap(Transformer)].
    * link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-[DirectoryProperty.file(String)]

link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider]<link:{javadocPath}/org/gradle/api/file/Directory.html[Directory]>:: Directory on disk
  Factories;;
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-[Provider.map(Transformer)].
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-[Provider.flatMap(Transformer)].
    * link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-[DirectoryProperty.dir(String)]

link:{javadocPath}/org/gradle/api/file/FileCollection.html[FileCollection]:: Unstructured collection of files
  Factories;;
    * link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[Project.files(Object++[]++)]
    * link:{javadocPath}/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object++...++-[ProjectLayout.files(Object++...++)]
    * link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#files-java.lang.Object++...++-[DirectoryProperty.files(Object++...++)]

link:{javadocPath}/org/gradle/api/file/FileTree.html[FileTree]:: Hierarchy of files
  Factories;;
    * link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)[Project.fileTree(Object)] will produce a link:{javadocPath}/org/gradle/api/file/ConfigurableFileTree.html[ConfigurableFileTree], or you can use link:{javadocPath}/org/gradle/api/Project.html#zipTree-java.lang.Object-[Project.zipTree(Object)] and link:{javadocPath}/org/gradle/api/Project.html#tarTree-java.lang.Object-[Project.tarTree(Object)]
    * link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--[DirectoryProperty.getAsFileTree()]

== Property Files API Reference

Use these types for _mutable_ values:

link:{javadocPath}/org/gradle/api/file/RegularFileProperty.html[RegularFileProperty]:: File on disk
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#fileProperty--[ObjectFactory.fileProperty()]

link:{javadocPath}/org/gradle/api/file/DirectoryProperty.html[DirectoryProperty]:: Directory on disk
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#directoryProperty--[ObjectFactory.directoryProperty()]

link:{javadocPath}/org/gradle/api/file/ConfigurableFileCollection.html[ConfigurableFileCollection]:: Unstructured collection of files
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#fileCollection--[ObjectFactory.fileCollection()]

link:{javadocPath}/org/gradle/api/file/ConfigurableFileTree.html[ConfigurableFileTree]:: Hierarchy of files
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#fileTree--[ObjectFactory.fileTree()]

link:{javadocPath}/org/gradle/api/file/SourceDirectorySet.html[SourceDirectorySet]:: Hierarchy of source directories
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#sourceDirectorySet-java.lang.String-java.lang.String-[ObjectFactory.sourceDirectorySet(String, String)]

== Lazy Collections API Reference

Use these types for _mutable_ values:

link:{javadocPath}/org/gradle/api/provider/ListProperty.html[ListProperty<T>]:: a property whose value is `List<T>`
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-[ObjectFactory.listProperty(Class)]

link:{javadocPath}/org/gradle/api/provider/SetProperty.html[SetProperty<T>]:: a property whose value is `Set<T>`
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-[ObjectFactory.setProperty(Class)]

== Lazy Objects API Reference

Use these types for _read only_ values:

link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider<T>]:: a property whose value is an instance of `T`
  Factories;;
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-[Provider.map(Transformer)].
    * link:{javadocPath}/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-[Provider.flatMap(Transformer)].
    * link:{javadocPath}/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-[ProviderFactory.provider(Callable)]. Always prefer one of the other factory methods over this method.

Use these types for _mutable_ values:

link:{javadocPath}/org/gradle/api/provider/Property.html[Property<T>]:: a property whose value is an instance of `T`
  Factories;;
    * link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-[ObjectFactory.property(Class)]


[[task_configuration_avoidance]]
= Task Configuration Avoidance

This chapter provides an introduction to "configuration avoidance" when dealing with tasks and explains some guidelines for migrating your build to use the configuration avoidance APIs effectively. The API described here co-exists with an existing API that will be replaced with our usual deprecation process over several major releases.  As of Gradle 5.1, we recommend that the configuration avoidance APIs be used whenever tasks are created by custom plugins.

[[sec:how_does_it_work]]
== How does the configuration avoidance API work?

In a nutshell, the API allows builds to avoid the cost of creating and configuring tasks during Gradle's configuration phase when those tasks will never be executed.  For example, when running a compile task, other unrelated tasks, like code quality, testing and publishing tasks, will not be executed, so any time spent creating and configuring those tasks is unnecessary.  The configuration avoidance API avoids configuring tasks if they will not be needed during the course of a build, which can have a significant impact on total configuration time.

To avoid creating and configuring tasks, we say that a task is "registered" but not created.  When a task is in this state, it is known to the build, it can be configured, and references to it can be passed around, but the task object itself has not actually been created, and none of its configuration actions have been executed.  It will remain in this state until something in the build needs the instantiated task object (for instance if the task is executed on the command line or the task is a dependency of a task executed on the command line).  If the task object is never needed, then the task will remain in the registered state, and the cost of creating and configuring the task will be avoided.

In Gradle, you register a task using link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-[TaskContainer.register(java.lang.String)]. There are variations of this method that allow providing a task type and/or an action for modifying the task configuration. Instead of returning a task instance, the `register(...)` method returns a link:{javadocPath}/org/gradle/api/tasks/TaskProvider.html[TaskProvider], which is a reference to the task that can be used in many places where a normal task object might be used (for example when creating task dependencies).

[[sec:task_configuration_avoidance_guidelines]]
== Guidelines

[[sec:how_do_i_defer_creation]]
=== How do I defer task creation?

Effective task configuration avoidance requires build authors to change instances of link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-[TaskContainer.create(java.lang.String)] to link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-[TaskContainer.register(java.lang.String)].

Older versions of Gradle only support the `create(...)` API. The `create(...)` API eagerly creates and configures tasks when it is called and should be avoided.

Using `register(...)` alone may not be enough to avoid all task configuration completely. You may need to change other code that configures tasks by name or by type, as explained in the following sections.

[[sec:how_do_i_defer_configuration]]
=== How do I defer task configuration?

Eager APIs like link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#all-org.gradle.api.Action-[DomainObjectCollection.all(org.gradle.api.Action)] and link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#withType-java.lang.Class-org.gradle.api.Action-[DomainObjectCollection.withType(java.lang.Class, org.gradle.api.Action)] will immediately create and configure any registered tasks. To defer task configuration, you will need to migrate to a configuration avoidance API equivalent. See the <<#sec:old_vs_new_configuration_api_overview,table below>> to identify the alternative.

[[sec:how_do_i_reference_a_task]]
=== How do I reference a task without creating/configuring it?

Instead of referencing a task object, you can work with a registered task via a link:{javadocPath}/org/gradle/api/tasks/TaskProvider.html[TaskProvider] object.  A link:{javadocPath}/org/gradle/api/tasks/TaskProvider.html[TaskProvider] can be obtained in several ways including when calling link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-[TaskContainer.register(java.lang.String)] or using the link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#named-java.lang.String-[TaskCollection.named(java.lang.String)] method.

Calling link:{javadocPath}/org/gradle/api/provider/Provider.html#get--[Provider.get()] or looking up a task by name with link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#getByName-java.lang.String-[TaskCollection.getByName(java.lang.String)] will cause the task to be created and configured. Methods like link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(java.lang.Object...)] and link:{javadocPath}/org/gradle/api/file/ConfigurableFileCollection.html#builtBy-java.lang.Object++...++-[ConfigurableFileCollection.builtBy(java.lang.Object++...++)] work with link:{javadocPath}/org/gradle/api/tasks/TaskProvider.html[TaskProvider] in the same way as link:{groovyDslPath}/org.gradle.api.Task.html[Task], so you do not need to unwrap a `Provider` for explicit dependencies to continue to work.

If you are configuring a task by name, you will need to use the configuration avoidance equivalent. See the <<#sec:old_vs_new_configuration_api_overview,table below>> to identify the alternative.

[[sec:how_do_i_get_a_task]]
=== How to get an instance of a Task?

In the event you still need to get access to a Task instance, you can use link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#named-java.lang.String-[TaskCollection.named(java.lang.String)] and call link:{javadocPath}/org/gradle/api/provider/Provider.html#get--[Provider.get()].  This will cause the task to be created/configured, but everything should work as it has with the eager APIs.

[[sec:how_do_i_order_tasks]]
=== How do I order tasks with configuration avoidance in mind?

[NOTE]
====
Calling ordering methods will not cause task creation by itself. All these methods do is declare relationships. However, it's important to note, that the existence of these relationships might indirectly cause task creation in later stages of the build process.
====

When task relationships need to be established (i.e. `dependsOn`, `finalizedBy`, `mustRunAfter`, `shouldRunAfter`), a distinction can be made between soft, and strong relationships, as their effects on task creation in configuration time differ:

link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object++[]++)[Task.mustRunAfter(...)] and link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:shouldRunAfter(java.lang.Object++[]++)[Task.shouldRunAfter(...)] represent soft relationships, which can only change the order of existing tasks, but can't trigger their creation.

link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(...)] and link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object++[]++)[Task.finalizedBy(...)] represent strong relationships, which will _force_ the execution of referenced tasks, even if they wouldn't have been created otherwise.

- If a task is _not_ executed (regardless if it was created with link:{groovyDslPath}/org.gradle.api.tasks.TaskContainer.html#org.gradle.api.tasks.TaskContainer:register(java.lang.String)[Task.register(...)] or link:{groovyDslPath}/org.gradle.api.tasks.TaskContainer.html#org.gradle.api.tasks.TaskContainer:create(java.lang.String)[Task.create(...)]), the defined relationships will not trigger any task creation at configuration time.
- If a task _is_ executed, all strongly associated tasks need to be created and configured at configuration time, as they might have other `dependsOn` or `finalizedBy` relationships. This will happen transitively, until the task graph contains all strong relationships.

[[sec:task_configuration_avoidance_migration_guidelines]]
== Migration Guide

The following sections will go through some <<#sec:task_configuration_avoidance_general, general guidelines>> to adhere to when migrating the build logic as well as <<#sec:task_configuration_avoidance_migration_steps, the steps>> we recommend following.
We also cover some <<#sec:task_configuration_avoidance_troubleshooting, troubleshooting>> and <<#sec:task_configuration_avoidance_pitfalls, pitfalls>> to help you work around some issues you may encounter during the migration.

[[sec:task_configuration_avoidance_general]]
=== General
1. [[task_configuration_avoidance_guideline_use_help_task]] **Use `help` task as a benchmark during the migration.**
The `help` task is the perfect candidate to benchmark your migration process.
In a build that uses only the configuration avoidance API, https://scans.gradle.com/s/o7qmlmmrsfxz4/performance/configuration?openScriptsAndPlugins=WzFd[a build scan would show no tasks created immediately or created during configuration], and only the tasks that were actually executed would be created.
Be mindful of <<#task_configuration_avoidance_pitfall_build_scan_plugin, the version of the build scan plugin in use>>.

2. [[task_configuration_avoidance_guideline_only_mutate_task_object]] **Only mutate the current task inside a configuration action.**
Because the task configuration action can now run immediately, later or never, mutating anything other than the current task can cause indeterminate behavior in your build.
Consider the following code:
+
====
[.multi-language-sample]
=====
[source,groovy]
----
def check = tasks.register("check")
tasks.register("verificationTask") { verificationTask ->
    // Configure verificationTask

    // Run verificationTask when someone runs check
    check.get().dependsOn verificationTask
}
----
=====
[.multi-language-sample]
=====
[source,kotlin]
----
val check by tasks.registering
tasks.register("verificationTask") {
    // Configure verificationTask

    // Run verificationTask when someone runs check
    check.get().dependsOn(this)
}
----
=====
====
Executing the `gradle check` task should execute `verificationTask`, but with this example, it won't.
This is because the dependency between `verificationTask` and `check` only happens when `verificationTask` is realized.
To avoid issues like this, you must only modify the task associated with the configuration action.
Other tasks should be modified in their own configuration action.
The code would become:
+
====
[.multi-language-sample]
=====
[source,groovy]
----
def check = tasks.register("check")
def verificationTask = tasks.register("verificationTask") {
    // Configure verificationTask
}
check.configure {
    dependsOn verificationTask
}
----
=====
[.multi-language-sample]
=====
[source,kotlin]
----
val check by tasks.registering
val verificationTask by tasks.registering {
    // Configure verificationTask
}
check {
    dependsOn(verificationTask)
}
----
=====
====
In the future, Gradle will consider this sort of anti-pattern an error and will produce an exception.

3. [[task_configuration_avoidance_guideline_prefer_small_incremental_change]] **Prefer small incremental changes.**
Smaller changes are easier to sanity check.
If you ever break your build logic, it will be easier to analyze the changelog since the last successful verification.

4. [[task_configuration_avoidance_guideline_validate_build_logic]] **Ensure a good plan is established for validating the build logic.**
Usually, a simple `build` task invocation should do the trick to validate your build logic.
However, some builds may need additional verification — understand the behavior of your build and make sure you have a good plan for verification.

5. [[task_configuration_avoidance_guideline_prefer_automatic_testing]] **Prefer automatic testing to manual testing.**
It’s good practice to write integration test for your build logic using TestKit.

6. [[task_configuration_avoidance_guideline_avoid_task_by_name]] **Avoid referencing a task by name.**
In the majority of cases, referencing a task by name is a fragile pattern and should be avoided.
Although the task name is available on the `TaskProvider`, effort should be made to use references from a strongly typed model instead.

7. **Use the new task API as much as possible.**
Eagerly realizing some tasks may cause a cascade of other tasks to be realized.
Using `TaskProvider` helps create an indirection that protects against transitive realization.

8. Some APIs may be disallowed if you try to access them from the new API's configuration blocks. For example,
link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:afterEvaluate(org.gradle.api.Action)[`Project.afterEvaluate()`]
cannot be called when configuring a task registered with the new API. Since `afterEvaluate` is used to delay configuring a `Project`, mixing delayed configuration
with the new API can cause errors that are hard to diagnose because tasks registered with the new API are not always configured, but an `afterEvaluate` block
may be expected to always execute.

[[sec:task_configuration_avoidance_migration_steps]]
=== Migration Steps
The first part of the migration process is to go through the code and manually migrate eager task creation and configuration to use configuration avoidance APIs.
The following explores the recommended steps for a successful migration.
While going through these steps, keep in mind <<#sec:task_configuration_avoidance_general, the guidelines>> above.

[NOTE]
====
Using the new API in a plugin will require users to use Gradle 4.9 or later. Plugin authors should refer to <<#sec:task_configuration_avoidance_backward_compatibility_migration>> section.
====

1. **Migrate task configuration that affects all tasks (`tasks.all {}`) or subsets by type (`tasks.withType(...) {}`).**
This will cause your build to eagerly create fewer tasks that are registered by plugins.

2. **Migrate tasks configured by name.**
Similar to the previous point, this will cause your build to eagerly create fewer tasks that are registered by plugins.
For example, logic that uses `TaskContainer#getByName(String, Closure)` should be converted to `TaskContainer#named(String, Action)`.
This also includes <<#task_configuration_avoidance_pitfalls_hidden_eager_task_realization, task configuration via DSL blocks>>.

3. **Migrate tasks creation to `register(...)`.**
At this point, you should change anywhere that you are creating tasks to instead register those tasks.


For all steps above, be aware of the <<#sec:task_configuration_avoidance_pitfalls, common pitfalls around deferred configuration>>.

After making these changes, you should see improvement in the number of tasks that are eagerly created at configuration time.  Use <<#sec:task_configuration_avoidance_troubleshooting, build scans>> to understand what tasks are still being created eagerly and where this is happening.

[[sec:task_configuration_avoidance_troubleshooting]]
=== Troubleshooting
* **What tasks are being realized?**
As we keep developing the feature, more reporting, and troubleshooting information will be made available to answer this question.
In the meantime, https://gradle.com/enterprise/releases/2018.3#reduce-configuration-time-by-leveraging-task-creation-avoidance[build scan is the best way to answer this question].
Follow these steps:

  a. https://scans.gradle.com/[Create a build scan].
  Execute the Gradle command using the `--scan` flag.

  b. Navigate to the configuration performance tab.
+
.Navigate to configuration performance tab in build scan
image::taskConfigurationAvoidance-navigate-to-performance.png[]
+
    1. Navigate to the performance card from the left side menu.
    2. Navigate to the configuration tab from the top of the performance card.

  c. All the information requires will be presented.
+
.Configuration performance tab in build scan annotated
image::taskConfigurationAvoidance-performance-annotated.png[]
+
    1. Total tasks present when each task is created or not.
      - "Created immediately" represents tasks that were created using the eager task APIs.
      - "Created during configuration" represents tasks that were created using the configuration avoidance APIs, but were realized explicitly (via `TaskProvider#get()`) or implicitly using the eager task query APIs.
      - Both "Created immediately" and "Created during configuration" numbers are considered the "bad" numbers that should be minimized as much as possible.
      - "Created during task graph calculation" represents the tasks created when building the execution task graph.
      Ideally, this number would be equal to the number of tasks executed.
      - "Not created" represents the tasks that were avoided in this build session.

    2. The next section helps answer the question of where a task was realized. For each script, plugin or lifecycle callback, the last column represents the tasks that were created either immediately or during configuration.
    Ideally, this column should be empty.

    3. Focusing on a script, plugin, or lifecycle callback will show a break down of the tasks that were created.

[[sec:task_configuration_avoidance_pitfalls]]
=== Pitfalls

* [[task_configuration_avoidance_pitfalls_hidden_eager_task_realization]] **Beware of the hidden eager task realization.**
There are many ways that a task can be configured eagerly.  For example, configuring a task using the task name and a DSL block will cause the task to immediately be created when using the Groovy DSL:
+
[source,groovy]
----
// Given a task lazily created with
tasks.register("someTask")

// Some time later, the task is configured using a DSL block
someTask {
    // This causes the task to be created and this configuration to be executed immediately
}
----
+
Instead use the `named()` method to acquire a reference to the task and configure it:
+
[source,groovy]
----
tasks.named("someTask") {
    // ...
    // Beware of the pitfalls here
}
----
+
Similarly, Gradle has syntactic sugar that allows tasks to be referenced by name without an explicit query method.  This can also cause the task to be immediately created:
+
[source,groovy]
----
tasks.register("someTask")

// Sometime later, an eager task is configured like
task anEagerTask {
    // The following will cause "someTask" to be looked up and immediately created
    dependsOn someTask
}
----
+
There are several ways this premature creation can be avoided:

  - **Use a `TaskProvider` variable.**
  Useful when the task is referenced multiple times in the same build script.
+
====
[.multi-language-sample]
=====
[source,groovy]
----
def someTask = tasks.register("someTask")

task anEagerTask {
    dependsOn someTask
}
----
=====
[.multi-language-sample]
=====
[source,kotlin]
----
val someTask by tasks.registering

task("anEagerTask") {
    dependsOn(someTask)
}
----
=====
====

    - **Migrate the consumer task to the new API.**
+
[source,groovy]
----
tasks.register("someTask")

tasks.register("anEagerTask") {
    dependsOn someTask
}
----

    - **Lookup the task lazily.**
    Useful when the tasks are not created by the same plugin.
+
====
[.multi-language-sample]
=====
[source,groovy]
----
tasks.register("someTask")

task anEagerTask {
    dependsOn tasks.named("someTask")
}
----
=====
[.multi-language-sample]
=====
[source,kotlin]
----
tasks.register("someTask")

task("anEagerTask") {
    dependsOn(tasks.named("someTask"))
}
----
=====
====

* [[task_configuration_avoidance_pitfall_build_scan_plugin]] **The build scan plugin `buildScanPublishPrevious` task is eager until version 1.15.** Upgrade the build scan plugin in your build to use the latest version.

[[sec:task_configuration_avoidance_backward_compatibility_migration]]
==== Supporting older versions of Gradle

This section describes two ways to keep your plugin backward compatible with older version of Gradle if you must maintain compatibility with versions of Gradle older than 4.9. Most of the new API methods are available starting with Gradle 4.9.

[NOTE]
====
Although backward compatibility is good for users, we still recommended to upgrade to newer Gradle releases in a timely manner. This will reduce your maintenance burden.
====

The first method to maintain compatibility is to compile your plugin against the Gradle 4.9 API and conditionally call the right APIs with Groovy (https://github.com/melix/jmh-gradle-plugin/blob/a034aa88805b7a06fa9c5a825d573554b2aa23e2/src/main/groovy/me/champeau/gradle/JMHPlugin.groovy#L289-L296[example]).

The second method is to use Java reflection to cope with the fact that the APIs are unavailable during compilation (https://github.com/tbroyer/gradle-apt-plugin/tree/432509ec85d1ab49296d4f9b21fad876523c6a8a/src/main/java/net/ltgt/gradle/apt[example]).

It is highly recommended to have cross-version test coverage using <<test_kit.adoc#sub:gradle-runner-gradle-version, TestKit>> and multiple versions of Gradle.

[[sec:old_vs_new_configuration_api_overview]]
== Existing vs New API overview

[NOTE]
====
* Methods that take a `groovy.lang.Closure` are covered in the new API with methods taking `org.gradle.api.Action`.
* More convenience methods may be added in the future based on user feedback.
* Some old API methods may never have a direct replacement in the new API.
* Some APIs may be restricted when accessed in a configuration action registered via the configuration avoidance methods.
====

[cols="a,a", options="header"]
|===
| Old vs New API
| Description

| Instead of: `task myTask(type: MyTask) {}`
.2+| There is not a shorthand Groovy DSL for using the new API.
| Use: `tasks.register("myTask", MyTask) {}`

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.util.Map-[TaskContainer.create(java.util.Map)]
.2+| Use one of the alternatives below.
| Use: No direct equivalent.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.util.Map-groovy.lang.Closure-[TaskContainer.create(java.util.Map, groovy.lang.Closure)]
.2+| Use one of the alternatives below.
| Use: No direct equivalent.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-[TaskContainer.create(java.lang.String)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-[TaskContainer.register(java.lang.String)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-groovy.lang.Closure-[TaskContainer.create(java.lang.String, groovy.lang.Closure)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-org.gradle.api.Action-[TaskContainer.register(java.lang.String, org.gradle.api.Action)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-java.lang.Class-[TaskContainer.create(java.lang.String, java.lang.Class)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-[TaskContainer.register(java.lang.String, java.lang.Class)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-java.lang.Class-org.gradle.api.Action-[TaskContainer.create(java.lang.String, java.lang.Class, org.gradle.api.Action)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-org.gradle.api.Action-[TaskContainer.register(java.lang.String, java.lang.Class, org.gradle.api.Action)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-java.lang.Class-java.lang.Object++...++-[TaskContainer.create(java.lang.String, java.lang.Class, java.lang.Object...)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-java.lang.Object++...++-[TaskContainer.register(java.lang.String, java.lang.Class, java.lang.Object...)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#getByName-java.lang.String-[TaskCollection.getByName(java.lang.String)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#named-java.lang.String-[TaskCollection.named(java.lang.String)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#getByName-java.lang.String-groovy.lang.Closure-[TaskCollection.getByName(java.lang.String, groovy.lang.Closure)]
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: `named(java.lang.String, Action)`

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#getByPath-java.lang.String-[TaskContainer.getByPath(java.lang.String)]
.2+| Accessing tasks from another project requires a specific ordering of project evaluation.
| Use: No direct equivalent.

| Instead of: link:{javadocPath}/org/gradle/api/NamedDomainObjectCollection.html#findByName-java.lang.String-[NamedDomainObjectCollection.findByName(java.lang.String)]
.2+| `named(String)` is the closest equivalent, but will fail if the task does not exist. Using `findByName(String)` will cause tasks registered with the new API to be created/configured.
| Use: No direct equivalent.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#findByPath-java.lang.String-[TaskContainer.findByPath(java.lang.String)]
.2+| See `getByPath(String)` above.
| Use: No direct equivalent.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-[TaskCollection.withType(java.lang.Class)]
.2+| This is OK to use because it does not require tasks to be created immediately.
| Use: _OK_

| Instead of: `withType(java.lang.Class).getByName(java.lang.String)`
.2+| This returns a `TaskProvider` instead of a `Task`.
| Use: `named(java.lang.String, java.lang.Class)`

| Instead of: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#withType-java.lang.Class-org.gradle.api.Action-[DomainObjectCollection.withType(java.lang.Class, org.gradle.api.Action)]
.2+| This returns `void`, so it cannot be chained.
| Use: `withType(java.lang.Class).configureEach(org.gradle.api.Action)`

| Instead of: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#all-org.gradle.api.Action-[DomainObjectCollection.all(org.gradle.api.Action)]
.2+| This returns `void`, so it cannot be chained.
| Use: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#configureEach-org.gradle.api.Action-[DomainObjectCollection.configureEach(org.gradle.api.Action)]

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#whenTaskAdded-org.gradle.api.Action-[TaskCollection.whenTaskAdded(org.gradle.api.Action)]
.2+| This returns `void`, so it cannot be chained.
| Use: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#configureEach-org.gradle.api.Action-[DomainObjectCollection.configureEach(org.gradle.api.Action)]

| Instead of: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#whenObjectAdded-org.gradle.api.Action-[DomainObjectCollection.whenObjectAdded(org.gradle.api.Action)]
.2+| This returns `void`, so it cannot be chained.
| Use: link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#configureEach-org.gradle.api.Action-[DomainObjectCollection.configureEach(org.gradle.api.Action)]

| Instead of: link:{javadocPath}/org/gradle/api/NamedDomainObjectSet.html#findAll-groovy.lang.Closure-[NamedDomainObjectSet.findAll(groovy.lang.Closure)]
.2+| Avoid calling this method. `matching(Spec)` and `configureEach(Action)` are more appropriate in most cases.
| Use: _OK_, with issues.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#matching-groovy.lang.Closure-[TaskCollection.matching(groovy.lang.Closure)]
.2+| `matching(Spec)` requires all tasks to be created, so try to limit the impact by restricting the type of task, like `withType(java.lang.Class).matching(Spec)`.
| Use: _OK_, with issues.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#getAt-java.lang.String-[TaskCollection.getAt(java.lang.String)]
.2+| Avoid calling this directly as it's a Groovy convenience method. The alternative returns a `TaskProvider` instead of a `Task`.
| Use: link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#named-java.lang.String-[TaskCollection.named(java.lang.String)]

| Instead of: `iterator()` or implicit iteration over the `Task` collection
.2+| Avoid doing this as it requires creating and configuring all tasks. See `findAll(Closure)` above.
| Use: _OK_, with issues.

| Instead of: `remove(org.gradle.api.Task)`
.2+| Avoid calling this. The behavior of `remove` with the new API may change in the future.
| Use: _OK_, with issues.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#replace-java.lang.String-[TaskContainer.replace(java.lang.String)]
.2+| Avoid calling this. The behavior of `replace` with the new API may change in the future.
| Use: _OK_, with issues.

| Instead of: link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html#replace-java.lang.String-java.lang.Class-[TaskContainer.replace(java.lang.String, java.lang.Class)]
.2+| Avoid calling this. The behavior of `replace` with the new API may change in the future.
| Use: _OK_, with issues.

|===

== Configuration using properties

The custom Gradle types that you implement often hold some configuration that you want to make available to build scripts and other plugins.
For example, a download task may have configuration that specifies the URL to download from and the file system location to write the result to.

[[managed_properties]]
=== Managed properties

Gradle provides its own _managed properties_ concept that allows you to declare each property as an abstract getter (Java, Groovy) or an abstract property (Kotlin).
Gradle then provides the implementation for such a property automatically.
It is called a _managed property_, as Gradle takes care of managing the state of the property.
A property may be _mutable_, meaning that it has both a `get()` method and `set()` method, or _read-only_, meaning that it has only a `get()` method.
_Read-only_ properties are also called _providers_.

==== Mutable managed properties

To declare a mutable managed property, add an abstract getter method of type `Property<T>` - where `T` can be any serializable type or a fully Gradle <<#managed_types,managed type>>.
(See the list further down for more specific property types.)
The property must not have any setter methods.
Here is an example of a task type with an `uri` property of type `URI`:

.Mutable managed property
====
[source.multi-language-sample,java]
.Download.java
----
include::{snippetsPath}/plugins/mutableManagedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
----
====

Note that for a property to be considered a mutable managed property, the property's getter methods must be `abstract` and have `public` or `protected` visibility.
The property type must be one of the following:

- `Property<T>`
- `RegularFileProperty`
- `DirectoryProperty`
- `ListProperty<T>`
- `SetProperty<T>`
- `MapProperty<K, V>`
- `ConfigurableFileCollection`
- `ConfigurableFileTree`
- `DomainObjectSet<T>`
- `NamedDomainObjectContainer<T>`

Gradle creates values for managed properties in the same way as link:{javadocPath}/org/gradle/api/model/ObjectFactory.html[ObjectFactory].

[[read_only_managed_properties]]
==== Read-only managed properties

To declare a read-only managed property, also called provider, add a getter method of type `Provider<T>`.
The method implementation then needs to derive the value, for example from other properties.

Here is an example of a task type with a `uri` provider that is derived from a `location` property:

.Read-only managed property
====
[source.multi-language-sample,java]
.Download.java
----
include::{snippetsPath}/plugins/readOnlyManagedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
----
====

[[read_only_managed_nested_properties]]
==== Read-only managed nested properties

To declare a read-only managed nested property, add an abstract getter method for the property to the type annotated with `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]`.
The property should not have any setter methods.
Gradle provides an implementation for the getter method, and also creates a value for the property.
The nested type is also treated as a custom type, and can use the features discussed in this chapter.

This pattern is useful when a custom type has a nested complex type which has the same lifecycle.
If the lifecycle is different, consider using `Property<NestedType>` instead.

Here is an example of a task type with a `resource` property. The `Resource` type is also a custom Gradle type and defines some managed properties:

.Read-only managed nested property
====
[source.multi-language-sample,java]
.Download.java
----
include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Download.java[tags=download]
include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
----
====

Note that for a property to be considered a read-only managed nested property, the property's getter methods must be `abstract` and have `public` or `protected` visibility.
The property must not have any setter methods.
In addition, the property getter must be annotated with `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]`.

[[read_only_managed_name_property]]
==== Read-only managed "name" property

If the type contains an abstract property called "name" of type `String`, Gradle provides an implementation for the getter
method, and extends each constructor with a "name" parameter, which comes before all other constructor parameters. If the
type is an interface, Gradle will provide a constructor with a single "name" parameter and `@Inject` semantics.

You can have your type implement or extend the link:{javadocPath}/org/gradle/api/Named.html[Named] interface, which defines
such a read-only "name" property.

[[managed_types]]
=== Managed types

A _managed type_ is an abstract class or interface with no fields and whose properties are all managed.
That is, it is a type whose state is entirely managed by Gradle.

A _named managed type_ is a managed type that additionally has an abstract property "name" of type `String`. Named
managed types are especially useful as the element type of link:{javadocPath}/org/gradle/api/NamedDomainObjectContainer.html[NamedDomainObjectContainer] (see below).

.Managed type defined as interface
====
[source.multi-language-sample,java]
.Resource.java
----
include::{snippetsPath}/plugins/readOnlyNestedProperty/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
----
====

=== Java bean properties.

Sometimes you may see properties implemented in the Java bean property style.
That is, they do not use a `Property<T>` or `Provider<T>` types but are instead implemented with concrete setter and getter methods (or corresponding conveniences in Groovy or Kotlin).
This style of property definition is legacy in Gradle and is discouraged.
Properties in Gradle's core plugins that are still of this style will be migrated to managed properties in future versions.



[[collection_types]]
== Collection types

Gradle provides types for maintaining collections of objects, intended to work well to extends Gradle's DSLs and provide useful features such as lazy configuration.

=== NamedDomainObjectContainer

A link:{javadocPath}/org/gradle/api/NamedDomainObjectContainer.html[NamedDomainObjectContainer] manages a set of objects, where each element has a name associated with it.
The container takes care of creating and configuring the elements, and provides a DSL that build scripts can use to define and configure elements.
It is intended to hold objects which are themselves configurable, for example a set of custom Gradle objects.

Gradle uses `NamedDomainObjectContainer` type extensively throughout the API.
For example, the `project.tasks` object used to manage the tasks of a project is a `NamedDomainObjectContainer<Task>`.

You can create a container instance using the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html[ObjectFactory] service, which provides the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#domainObjectContainer-java.lang.Class-[ObjectFactory.domainObjectContainer()] method.
This is also available using the link:{javadocPath}/org/gradle/api/Project.html#container-java.lang.Class-[Project.container()] method, however in a custom Gradle type it's
generally better to use the injected `ObjectFactory` service instead of passing around a `Project` instance.

You can also create a container instance using a <<read_only_managed_properties,read-only managed property>>, described above.

In order to use a type with any of the `domainObjectContainer()` methods, it must either

- be a <<managed_types,named managed type>>; or
- expose a property named "`name`" as the unique, and constant, name for the object. The `domainObjectContainer(Class)`
  variant of the method creates new instances by calling the constructor of the class that takes a string argument, which is the desired name of the object.

Objects created this way are treated as custom Gradle types, and so can make use of the features discussed in this chapter, for example service injection or
managed properties.

See the above link for `domainObjectContainer()` method variants that allow custom instantiation strategies.

.Managing a collection of objects
====
[source.multi-language-sample,java]
.DownloadExtension.java
----
include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/DownloadExtension.java[tags=download-extension]
include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/Resource.java[tags=resource]
----
====

For each container property, Gradle automatically adds a block to the Groovy and Kotlin DSL that you can use to configure the
contents of the container:

.Configure block
====
[source.multi-language-sample,kotlin]
.build.gradle.kts
----
include::{snippetsPath}/plugins/namedDomainObjectContainer/kotlin/build.gradle.kts[]
----
[source.multi-language-sample,groovy]
.build.gradle
----
include::{snippetsPath}/plugins/namedDomainObjectContainer/groovy/build.gradle[]
----
====

=== ExtensiblePolymorphicDomainObjectContainer

An link:{javadocPath}/org/gradle/api/ExtensiblePolymorphicDomainObjectContainer.html[ExtensiblePolymorphicDomainObjectContainer] is a `NamedDomainObjectContainer` that allows you to
define instantiation strategies for different types of objects.

You can create an instance using the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#polymorphicDomainObjectContainer-java.lang.Class-[ObjectFactory.polymorphicDomainObjectContainer()] method.

=== NamedDomainObjectSet

A link:{javadocPath}/org/gradle/api/NamedDomainObjectSet.html[NamedDomainObjectSet] holds a set of configurable objects, where each element has a name associated with it.
This is similar to `NamedDomainObjectContainer`, however a `NamedDomainObjectSet` doesn't manage the objects in the collection. They need to be created and added manually.

You can create an instance using the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#namedDomainObjectSet-java.lang.Class-[ObjectFactory.namedDomainObjectSet()] method.

=== NamedDomainObjectList

A link:{javadocPath}/org/gradle/api/NamedDomainObjectList.html[NamedDomainObjectList] holds a list of configurable objects, where each element has a name associated with it.
This is similar to `NamedDomainObjectContainer`, however a `NamedDomainObjectList` doesn't manage the objects in the collection. They need to be created and added manually.

You can create an instance using the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#namedDomainObjectList-java.lang.Class-[ObjectFactory.namedDomainObjectList()] method.

=== DomainObjectSet

A link:{javadocPath}/org/gradle/api/DomainObjectSet.html[DomainObjectSet] simply holds a set of configurable objects.
Compared to `NamedDomainObjectContainer`, a `DomainObjectSet` doesn't manage the objects in the collection. They need to be created and added manually.

You can create an instance using the link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#domainObjectSet-java.lang.Class-[ObjectFactory.domainObjectSet()] method.
