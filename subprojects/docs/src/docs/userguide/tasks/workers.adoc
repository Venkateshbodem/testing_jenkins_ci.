// Copyright 2022 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[tasks_parallel_worker]]
= Parallelize Tasks with Workers

The Worker API provides the ability to break up the execution of a task action into discrete units of work and then to execute that work concurrently and asynchronously.
This allows Gradle to fully utilize the resources available and complete builds faster.
This section will walk you through the process of converting an existing custom task to use the Worker API.

This section assumes that you understand the basics of writing Gradle custom tasks.
For more information on that topic, consult the <<custom_tasks.adoc#custom_tasks,section on custom tasks>>.

You'll start by creating a custom task class that generates MD5 hashes for a configurable set of files.
Then, you'll convert this custom task to use the Worker API.
Then we'll explore running the task with different levels of isolation.
In the process, you'll learn about the basics of the Worker API and the capabilities it provides.

== Create a custom task class

First, you'll need to create a custom task that generates MD5 hashes of a configurable set of files.

In a new directory, create a `buildSrc/build.gradle(.kts)` file.

====
include::sample[dir="snippets/workerApi/md5CustomTask/groovy",files="buildSrc/build.gradle[]"]
include::sample[dir="snippets/workerApi/md5CustomTask/kotlin",files="buildSrc/build.gradle.kts[]"]
====
<1> Your custom task class will use https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] to generate MD5 hashes.

TIP: If you are not familiar with `buildSrc`, this is a special directory that allows you to define and build custom classes that should be available for use in your build script.
See <<organizing_gradle_projects.adoc#sec:build_sources,the section on organizing build logic>> for further information.

Now, create a custom task class in your `buildSrc/src/main/java` directory.
You should name this class `CreateMD5`.

.buildSrc/src/main/java/CreateMD5.java
[source,java]
----
include::{snippetsPath}/workerApi/md5CustomTask/groovy/buildSrc/src/main/java/CreateMD5.java[]
----
<1> link:{javadocPath}/org/gradle/api/tasks/SourceTask.html[SourceTask] is a convenience type for tasks that operate on a set of source files.
<2> The output of the task will go into a configured directory.
<3> The task iterates over all of the files defined as "source files" and creates an MD5 hash of each.
<4> Insert an artificial sleep to simulate hashing a large file (the sample files won't be that large).
<5> The MD5 hash of each file is written to the output directory into a file of the same name with an "md5" extension.

Next, create a `build.gradle(.kts)` that registers your new `CreateMD5` task.

====
include::sample[dir="snippets/workerApi/md5CustomTask/groovy",files="build.gradle[]"]
include::sample[dir="snippets/workerApi/md5CustomTask/kotlin",files="build.gradle.kts[]"]
====
<1> Apply the `base` plugin so that you'll have a `clean` task to use to remove the output.
<2> MD5 hash files will be written to `build/md5`.
<3> This task will generate MD5 hash files for every file in the `src` directory.

Now, you'll need some source to generate MD5 hashes from.
Create 3 files in the src directory:

.src/einstein.txt
[source,text]
----
include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/einstein.txt[]
----

.src/feynman.txt
[source,text]
----
include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/feynman.txt[]
----

.src/oppenheimer.txt
[source,text]
----
include::{snippetsPath}/workerApi/md5CustomTask/groovy/src/oppenheimer.txt[]
----

At this point, you can give your task a try:

[listing]
----
$ gradle md5
----

You should see output similar to:

[listing]
----
include::{snippetsPath}/workerApi/md5CustomTask/tests/md5Task.out[]
----

In the `build/md5` directory, you should now see corresponding files with an `md5` extension containing MD5 hashes of the files from the `src` directory.
Notice that the task takes at least 9 seconds to run because it hashes each file one at a time (i.e. 3 files at \~3 seconds a piece).

== Converting to the Worker API

Although this task processes each file in sequence, the processing of each file is independent of any other file.
It would be really nice if this work was done in parallel and could take advantage of multiple processors.
This is where the Worker API can help.

First, you'll need to define an interface that represents the parameters of each unit of work and extends `org.gradle.workers.WorkParameters`.
For the generation of MD5 hash files, the unit of work will require two parameters: the file to be hashed and the file to write the hash to.
There is no need to create a concrete implementation, though, because Gradle will generate one for us at runtime.

.buildSrc/src/main/java/MD5WorkParameters.java
[source,java]
----
include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/MD5WorkParameters.java[]
----
<1> Use `Property` objects to represent the source and MD5 hash files.

Second, you'll need to refactor the part of your custom task that does the work for each individual file into a separate class.
This class is your "unit of work" implementation and it should be an abstract class that extends `org.gradle.workers.WorkAction`.

.buildSrc/src/main/java/GenerateMD5.java
[source,java]
----
include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/GenerateMD5.java[]
----
<1> Do not implement the `getParameters()` method - Gradle will inject this at runtime.

Now, you should change your custom task class to submit work to the
link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor] instead of doing the work itself.

.buildSrc/src/main/java/CreateMD5.java
[source,java]
----
include::{snippetsPath}/workerApi/md5NoIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
----
<1> You'll need to have the link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor] service in order to submit your work.
    Create a abstract getter methods annotated `javax.inject.Inject` and Gradle will inject the service at runtime when the task is created.
<2> Before submitting work, you'll need to get a `WorkQueue` object with the desired isolation mode.
    We'll talk more about isolation modes later.
<3> When submitting the unit of work, specify the unit of work implementation, in this case `GenerateMD5` and configure its parameters.

At this point, you should be able to try your task again.

[listing]
----
$ gradle clean md5

include::{snippetsPath}/workerApi/md5NoIsolation/tests/md5Task.out[]
----

The results should look the same as before, although the MD5 hash files may be generated in a different order due to the fact that the units of work are executed in parallel.
One thing you should notice, however, is that the task runs much faster.
This is because the Worker API executes the MD5 calculation for each file in parallel rather than in sequence.

== Changing the isolation mode

The isolation mode controls how strongly Gradle will isolate items of work from each other as well as from the rest of the Gradle runtime.
There are three methods on `WorkerExecutor` that control this:
`noIsolation()`, `classLoaderIsolation()` and `processIsolation()`.
The `noIsolation()` mode is the lowest level of isolation and will prevent a unit of work from changing the project state.
This is the fastest isolation mode because it requires the least overhead to set up the work item to execute, so you'll probably want to use this for simple cases.
However, it will use a single shared classloader for all units of work.
This means that each unit of work can potentially affect one another through static class state.
It also means that every unit of work uses the same version of libraries that are on the buildscript classpath.
If you wanted the user to be able to configure the task to run with a different (but compatible) version of the
https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] library, you would need to use a different isolation mode.

First, you'll want to change the dependency in `buildSrc/build.gradle` to be `compileOnly`.
This tells Gradle that it should use this dependency when building the classes, but should not put it on the build script classpath.

====
include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/groovy",files="buildSrc/build.gradle[]"]
include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/kotlin",files="buildSrc/build.gradle.kts[]"]
====

Next, you'll want to change the `CreateMD5` task to allow the user to configure the version of the codec library that they want to use.
It'll resolve the appropriate version of the library at runtime and configure the workers to use this version.
The `classLoaderIsolation()` method tells Gradle to run this work in a thread with an isolated classloader.

.buildSrc/src/main/java/CreateMD5.java
[source, groovy]
----
include::{snippetsPath}/workerApi/md5ClassloaderIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
----
<1> Expose an input property for the codec library classpath.
<2> Configure the classpath on the link:{javadocPath}/org/gradle/workers/ClassLoaderWorkerSpec.html[ClassLoaderWorkerSpec] when creating the work queue.

Next, you'll need to configure your build so that it has a repository to look up the codec version at task execution time.
We'll also create a dependency to resolve our codec library from this repository.

====
include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/groovy",files="build.gradle[]"]
include::sample[dir="snippets/workerApi/md5ClassloaderIsolation/kotlin",files="build.gradle.kts[]"]
====

<1> Add a repository to resolve the codec library - this can be a different repository than the one used to build the `CreateMD5` task class.
<2> Add a _configuration_ to resolve our codec library version.
<3> Configure an alternate, compatible version of https://commons.apache.org/proper/commons-codec/[Apache Commons Codec].
<4> Configure the `md5` task to use the configuration as its classpath.
    Note that the configuration will not be resolved until the task is actually executed.

Now, if you run your task, it should work as expected using the configured version of the codec library:

[listing]
----
$ gradle clean md5

include::{snippetsPath}/workerApi/md5ClassloaderIsolation/tests/md5Task.out[]
----

== Creating a Worker Daemon

Sometimes it is desirable to create even further isolation when executing items of work.
For instance, external libraries may rely on certain system properties to be set which may conflict between work items.
Or a library might not be compatible with the version of JDK that Gradle is running with and may need to be run with a different version.
The Worker API can accommodate this using the `processIsolation()` method that causes the work to execute in a separate "worker daemon".
These worker daemon processes will persist across builds and can be reused during subsequent builds.
If system resources get low, however, Gradle will stop any unused worker daemons.

To utilize a worker daemon, simply use the `processIsolation()` method when creating the `WorkQueue`.
You may also want to configure custom settings for the new process.

.buildSrc/src/main/java/CreateMD5.java
[source,java]
----
include::{snippetsPath}/workerApi/md5ProcessIsolation/groovy/buildSrc/src/main/java/CreateMD5.java[]
----
<1> Change the isolation mode to `PROCESS`.
<2> Set up the link:{javadocPath}/org/gradle/process/JavaForkOptions.html[JavaForkOptions] for the new process.

Now, you should be able to run your task, and it will work as expected but using worker daemons instead:

[listing]
----
$ gradle clean md5

include::{snippetsPath}/workerApi/md5ProcessIsolation/tests/md5Task.out[]
----

Note that the execution time may be somewhat high.
This is because Gradle has to start a new process for each worker daemon, which is expensive.
However, if you run your task again, you'll see that it runs much faster.
This is because the worker daemon(s) started during the initial build have persisted and are available for use immediately during subsequent builds.

[listing]
----
$ gradle clean md5

include::{snippetsPath}/workerApi/md5ProcessIsolation/tests/md5Task.out[]
----

[[worker_api]]
== The Worker API

As can be seen from the discussion of <<#incremental_tasks,incremental tasks>>, the work that a task performs can be viewed as discrete units (i.e. a subset of inputs that are transformed to a certain subset of outputs). Many times, these units of work are highly independent of each other, meaning they can be performed in any order and simply aggregated together to form the overall action of the task. In a single threaded execution, these units of work would execute in sequence, however if we have multiple processors, it would be desirable to perform independent units of work concurrently. By doing so, we can fully utilize the available resources at build time and complete the activity of the task faster.

The Worker API provides a mechanism for doing exactly this. It allows for safe, concurrent execution of multiple items of work during a task action. But the benefits of the Worker API are not confined to parallelizing the work of a task. You can also configure a desired level of isolation such that work can be executed in an isolated classloader or even in an isolated process. Furthermore, the benefits extend beyond even the execution of a single task. Using the Worker API, Gradle can begin to execute tasks in parallel by default. In other words, once a task has submitted its work to be executed asynchronously, and has exited the task action, Gradle can then begin the execution of other independent tasks in parallel, even if those tasks are in the same project.

[[using-the-worker-api]]
=== Using the Worker API

[NOTE]
====
A step-by-step description of converting a normal task action to use the worker API can be found in the section on <<worker_api.adoc#tasks_parallel_worker,developing parallel tasks>>.
====

In order to submit work to the Worker API, two things must be provided: an implementation of the unit of work, and the parameters for the unit of work.

The parameters for the unit of work are defined as an interface or abstract class that implements link:{javadocPath}/org/gradle/workers/WorkParameters.html[WorkParameters].
The parameters type must be a <<custom_gradle_types.adoc#managed_types,managed type>>.

You can find out more about implementing work parameters in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.

The implementation is a class that extends link:{javadocPath}/org/gradle/workers/WorkAction.html[WorkAction]. This class should be abstract and should not implement the `getParameters()` method. Gradle will inject an implementation of this method at runtime with the parameters object for each unit of work.

.Defining the unit of work parameters and implementation
====
include::sample[dir="snippets/workerApi/noIsolation/groovy",files="build.gradle[tags=unit-of-work]"]
include::sample[dir="snippets/workerApi/noIsolation/kotlin",files="build.gradle.kts[tags=unit-of-work]"]
====

A `WorkAction` implementation can inject services that provide capabilities during work execution, such as the link:{javadocPath}/org/gradle/api/file/FileSystemOperations.html[FileSystemOperations] service in the example above.  See <<custom_gradle_types.adoc#service_injection,Service Injection>> for further information on injecting service types.

In order to submit the unit of work, it is necessary to first acquire the link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor]. To do this, a task should have a constructor annotated with `javax.inject.Inject` that accepts a link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor] parameter. Gradle will inject the instance of link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor] at runtime when the task is created.  Then a link:{javadocPath}/org/gradle/workers/WorkQueue.html[WorkQueue] object can be created and individual items of work can be submitted.

.Submitting a unit of work for execution
====
include::sample[dir="snippets/workerApi/noIsolation/groovy",files="build.gradle[tags=task-implementation]"]
include::sample[dir="snippets/workerApi/noIsolation/kotlin",files="build.gradle.kts[tags=task-implementation]"]
====

Once all of the work for a task action has been submitted, it is safe to exit the task action. The work will be executed asynchronously and in parallel (up to the setting of `max-workers`). Of course, any tasks that are dependent on this task (and any subsequent task actions of this task) will not begin executing until all of the asynchronous work completes. However, other independent tasks that have no relationship to this task can begin executing immediately.

If any failures occur while executing the asynchronous work, the task will fail and a link:{javadocPath}/org/gradle/workers/WorkerExecutionException.html[WorkerExecutionException] will be thrown detailing the failure for each failed work item. This will be treated like any failure during task execution and will prevent any dependent tasks from executing.

In some cases, however, it might be desirable to wait for work to complete before exiting the task action. This is possible using the link:{javadocPath}/org/gradle/workers/WorkQueue.html#await--[WorkQueue.await()] method. As in the case of allowing the work to complete asynchronously, any failures that occur while executing an item of work will be surfaced as a link:{javadocPath}/org/gradle/workers/WorkerExecutionException.html[WorkerExecutionException] thrown from the link:{javadocPath}/org/gradle/workers/WorkQueue.html#await--[WorkQueue.await()] method.

[NOTE]
====

Note that Gradle will only begin running other independent tasks in parallel when a task has exited a task action and returned control of execution to Gradle. When link:{javadocPath}/org/gradle/workers/WorkQueue.html#await--[WorkQueue.await()] is used, execution does not leave the task action. This means that Gradle will not allow other tasks to begin executing and will wait for the task action to complete before doing so.

====

.Waiting for asynchronous work to complete
====
include::sample[dir="snippets/workerApi/waitForCompletion/groovy",files="build.gradle[tags=wait-for-completion]"]
include::sample[dir="snippets/workerApi/waitForCompletion/kotlin",files="build.gradle.kts[tags=wait-for-completion]"]
====

[[isolation-modes]]
=== Isolation Modes

Gradle provides three isolation modes that can be configured when creating a link:{javadocPath}/org/gradle/workers/WorkQueue.html[WorkQueue] and are specified using the one of the following methods on link:{javadocPath}/org/gradle/workers/WorkerExecutor.html[WorkerExecutor]:

link:{javadocPath}/org/gradle/workers/WorkerExecutor.html#noIsolation--[WorkerExecutor.noIsolation()]::
This states that the work should be run in a thread with a minimum of isolation. For instance, it will share the same classloader that the task is loaded from. This is the fastest level of isolation.
link:{javadocPath}/org/gradle/workers/WorkerExecutor.html#classLoaderIsolation-org.gradle.api.Action-[WorkerExecutor.classLoaderIsolation()]::
This states that the work should be run in a thread with an isolated classloader. The classloader will have the classpath from the classloader that the unit of work implementation class was loaded from as well as any additional classpath entries added through link:{javadocPath}/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--[ClassLoaderWorkerSpec.getClasspath()].
link:{javadocPath}/org/gradle/workers/WorkerExecutor.html#processIsolation-org.gradle.api.Action-[WorkerExecutor.processIsolation()]::
This states that the work should be run with a maximum level of isolation by executing the work in a separate process. The classloader of the process will use the classpath from the classloader that the unit of work was loaded from as well as any additional classpath entries added through link:{javadocPath}/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--[ClassLoaderWorkerSpec.getClasspath()]. Furthermore, the process will be a _Worker Daemon_ which will stay alive and can be reused for future work items that may have the same requirements. This process can be configured with different settings than the Gradle JVM using link:{javadocPath}/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-org.gradle.api.Action-[ProcessWorkerSpec.forkOptions(org.gradle.api.Action)].



[[worker-daemons]]
=== Worker Daemons

When using `processIsolation()`, gradle will start a long-lived _Worker Daemon_ process that can be reused for future work items.

.Submitting an item of work to run in a worker daemon
====
include::sample[dir="snippets/workerApi/workerDaemon/groovy",files="build.gradle[tags=worker-daemon]"]
include::sample[dir="snippets/workerApi/workerDaemon/kotlin",files="build.gradle.kts[tags=worker-daemon]"]
====

When a unit of work for a Worker Daemon is submitted, Gradle will first look to see if a compatible, idle daemon already exists. If so, it will send the unit of work to the idle daemon, marking it as busy. If not, it will start a new daemon. When evaluating compatibility, Gradle looks at a number of criteria, all of which can be controlled through link:{javadocPath}/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-org.gradle.api.Action-[ProcessWorkerSpec.forkOptions(org.gradle.api.Action)].

By default, a worker daemon starts with a maximum heap of 512MB. This can be changed by adjusting the workers fork options.

executable::
A daemon is considered compatible only if it uses the same java executable.
classpath::
A daemon is considered compatible if its classpath contains all of the classpath entries requested. Note that a daemon is considered compatible only if the classpath exactly matches the requested classpath.
heap settings::
A daemon is considered compatible if it has at least the same heap size settings as requested. In other words, a daemon that has higher heap settings than requested would be considered compatible.
jvm arguments::
A daemon is considered compatible if it has set all of the jvm arguments requested. Note that a daemon is considered compatible if it has additional jvm arguments beyond those requested (except for arguments treated specially such as heap settings, assertions, debug, etc).
system properties::
A daemon is considered compatible if it has set all of the system properties requested with the same values. Note that a daemon is considered compatible if it has additional system properties beyond those requested.
environment variables::
A daemon is considered compatible if it has set all of the environment variables requested with the same values. Note that a daemon is considered compatible if it has more environment variables in addition to those requested.
bootstrap classpath::
A daemon is considered compatible if it contains all of the bootstrap classpath entries requested. Note that a daemon is considered compatible if it has more bootstrap classpath entries in addition to those requested.
debug::
A daemon is considered compatible only if debug is set to the same value as requested (true or false).
enable assertions::
A daemon is considered compatible only if enable assertions is set to the same value as requested (true or false).
default character encoding::
A daemon is considered compatible only if the default character encoding is set to the same value as requested.


Worker daemons will remain running until either the build daemon that started them is stopped, or system memory becomes scarce. When available system memory is low, Gradle will begin stopping worker daemons in an attempt to minimize memory consumption.

== Cancellation and timeouts

In order to support cancellation (e.g. when the user stops the build with CTRL+C) and task timeouts, custom tasks should react to their executing thread being interrupted.
The same is true for work items submitted via the worker API. If a task does not respond to an interrupt within 10s, the daemon will shut down in order to free up system resources.
