// Copyright 2022 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[build_lifecycle]]
= Build Lifecycle

We said earlier that the core of Gradle is a language for dependency based programming. In Gradle terms this means that you can define tasks and dependencies between tasks. Gradle guarantees that these tasks are executed in the order of their dependencies, and that each task is executed only once. These tasks form a http://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed Acyclic Graph]. There are build tools that build up such a dependency graph as they execute their tasks. Gradle builds the complete dependency graph _before_ any task is executed. This lies at the heart of Gradle and makes many things possible which would not be possible otherwise.

Your build scripts configure this dependency graph. Therefore they are strictly speaking _build configuration scripts_.

[[sec:build_phases]]
== Build phases

A Gradle build has three distinct phases.

Initialization::
Gradle supports single and multi-project builds. During the initialization phase, Gradle determines which projects are going to take part in the build, and creates a link:{groovyDslPath}/org.gradle.api.Project.html[Project] instance for each of these projects.
Configuration::
During this phase the project objects are configured. The build scripts of _all_ projects which are part of the build are executed.
Execution::
Gradle determines the subset of the tasks, created and configured during the configuration phase, to be executed. The subset is determined by the task name arguments passed to the `gradle` command and the current directory. Gradle then executes each of the selected tasks.

[TIP]
.Maven Phases and Gradle
====
Gradle's build phases are not like Maven's phases.
Maven uses phases to divide the build execution into multiple stages.
Maven phases serve a similar role to Gradle's task graph, although less flexibly.

Maven's concept of a build lifecycle is loosely similar to Gradle's <<base_plugin#sec:base_tasks,lifecycle tasks>>.
====

[[sec:settings_file]]
== Settings file

Beside the build script files, Gradle defines a settings file. The settings file is determined by Gradle via a naming convention. The default name for this file is `settings.gradle`. Later in this chapter we explain how Gradle looks for a settings file.

The settings file is executed during the initialization phase. A multi-project build must have a `settings.gradle` file in the root project of the multi-project hierarchy. It is required because the settings file defines which projects are taking part in the multi-project build (see <<multi_project_builds.adoc#multi_project_builds,Authoring Multi-Project Builds>>). For a single-project build, a settings file is optional. Besides defining the included projects, you might need it to add libraries to your build script classpath (see <<organizing_gradle_projects.adoc#organizing_gradle_projects,Organizing Gradle Projects>>). Let's first do some introspection with a single project build:

.Single project build
====
include::sample[dir="snippets/buildlifecycle/basic/groovy",files="settings.gradle[];build.gradle[]"]
include::sample[dir="snippets/buildlifecycle/basic/kotlin",files="settings.gradle.kts[];build.gradle.kts[]"]
====

=== Output of **`gradle test testBoth`**
[source.multi-language-sample,groovy]
----
> gradle test testBoth
include::{snippetsPath}/buildlifecycle/basic/tests/buildlifecycle.out[]
----
[source.multi-language-sample,kotlin]
----
> gradle test testBoth
include::{snippetsPath}/buildlifecycle/basic/tests/buildlifecycle.out[]
----

For a build script, the property access and method calls are delegated to a project object. Similarly property access and method calls within the settings file is delegated to a settings object. Look at the link:{groovyDslPath}/org.gradle.api.initialization.Settings.html[Settings] class in the API documentation for more information.


[[sec:initialization]]
== Initialization

How does Gradle know whether to do a single or multi-project build?
If you trigger a multi-project build from a directory with a `settings.gradle` file, Gradle uses it to configure the build.
Gradle also allows you to execute the build from within any subproject taking part in the build.footnote:[Gradle supports partial multi-project builds (see <<intro_multi_project_builds.adoc#intro_multi_project_builds,Executing Multi-Project Builds>>).]
If you execute Gradle from within a project with no `settings.gradle` file, Gradle looks for a `settings.gradle` file in the following way:

* It looks for `settings.gradle` in parent directories.
* If not found, the build is executed as a single project build.
* If a `settings.gradle` file is found, Gradle checks if the current project is part of the multi-project hierarchy defined in the found `settings.gradle` file.
If not, the build is executed as a single project build. Otherwise a multi-project build is executed.

What is the purpose of this behavior? Gradle needs to determine whether the project you are in is a subproject of a multi-project build or not.
Of course, if it is a subproject, only the subproject and its dependent projects are built, but Gradle needs to create the build configuration for the whole multi-project build (see <<multi_project_configuration_and_execution.adoc#configuration_and_execution,Configuration and Execution>>).
If the current project contains a `settings.gradle` file, the build is always executed as:

* a single project build, if the `settings.gradle` file does not define a multi-project hierarchy
* a multi-project build, if the `settings.gradle` file does define a multi-project hierarchy.

The automatic search for a `settings.gradle` file only works for multi-project builds with a default project layout where project paths match the physical subproject layout on disk.
Gradle supports arbitrary physical layouts for a multi-project build, but for such arbitrary layouts you need to execute the build from the directory where the settings file is located.
For information on how to run partial builds from the root, see <<intro_multi_project_builds.adoc#sec:executing_tasks_by_fully_qualified_name,Executing tasks by their fully qualified name>>.

Gradle creates a Project object for every project taking part in the build. For a multi-project build these are the projects specified in the Settings object (plus the root project). Each project object has by default a name equal to the name of its top level directory, and every project except the root project has a parent project. Any project may have child projects.

[[sec:configuration_and_execution_of_a_single_project_build]]
== Configuration and execution of a single project build

For a single project build, the workflow of the _after initialization_ phases are pretty simple. The build script is executed against the project object that was created during the initialization phase. Then Gradle looks for tasks with names equal to those passed as command line arguments. If these task names exist, they are executed as a separate build in the order you have passed them. The configuration and execution for multi-project builds is discussed in <<multi_project_configuration_and_execution.adoc#configuration_and_execution,Configuration and Execution>>.

[[build_lifecycle_events]]
== Responding to the lifecycle in the build script

Your build script can receive notifications as the build progresses through its lifecycle. These notifications generally take two forms: You can either implement a particular listener interface, or you can provide a closure to execute when the notification is fired. The examples below use closures. For details on how to use the listener interfaces, refer to the API documentation.


[[sec:project_evaluation]]
=== Project evaluation

You can receive a notification immediately before and after a project is evaluated. This can be used to do things like performing additional configuration once all the definitions in a build script have been applied, or for some custom logging or profiling.

Below is an example which adds a `test` task to each project which has a `hasTests` property value of true.

.Adding of test task to each project which has certain property set
====
include::sample[dir="snippets/buildlifecycle/projectEvaluateEvents/groovy",files="build.gradle[tags=after-evaluate];project-a.gradle[]"]
include::sample[dir="snippets/buildlifecycle/projectEvaluateEvents/kotlin",files="build.gradle.kts[tags=after-evaluate];project-a.gradle.kts[]"]
====

.Output of `gradle -q test`
----
> gradle -q test
include::{snippetsPath}/buildlifecycle/projectEvaluateEvents/tests/projectEvaluateEvents.out[]
----

This example uses method `Project.afterEvaluate()` to add a closure which is executed after the project is evaluated (ie. the end of the configuration phase).

It is also possible to receive notifications when any project is evaluated. This example performs some custom logging of project evaluation. Notice that the `afterProject` notification is received regardless of whether the project evaluates successfully or fails with an exception.

.Notifications
====
include::sample[dir="snippets/buildlifecycle/buildProjectEvaluateEvents/groovy",files="build.gradle[tags=evaluate-events]"]
include::sample[dir="snippets/buildlifecycle/buildProjectEvaluateEvents/kotlin",files="build.gradle.kts[tags=evaluate-events]"]
====

==== Output of **`gradle -q test`**
[source.multi-language-sample,groovy]
----
> gradle -q test
include::{snippetsPath}/buildlifecycle/buildProjectEvaluateEvents/tests-groovy/buildProjectEvaluateEvents.groovy.out[]
----
[source.multi-language-sample,kotlin]
----
> gradle -q test
include::{snippetsPath}/buildlifecycle/buildProjectEvaluateEvents/tests-kotlin/buildProjectEvaluateEvents.kotlin.out[]
----

You can also add a link:{javadocPath}/org/gradle/api/ProjectEvaluationListener.html[ProjectEvaluationListener] to the link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html[Gradle] to receive these events.

[[sec:task_creation]]
=== Task creation

You can receive a notification immediately after a task is added to a project. This can be used to set some default values or add behaviour before the task is made available in the build file.

The following example sets the `srcDir` property of each task as it is created.

.Setting of certain property to all tasks
====
include::sample[dir="snippets/buildlifecycle/taskCreationEvents/groovy",files="build.gradle[]"]
include::sample[dir="snippets/buildlifecycle/taskCreationEvents/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle -q a`**
----
> gradle -q a
include::{snippetsPath}/buildlifecycle/taskCreationEvents/tests/taskCreationEvents.out[]
----

You can also add an link:{javadocPath}/org/gradle/api/Action.html[Action] to a link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[TaskContainer] to receive these events.

[[sec:task_execution_graph_ready]]
=== Task execution graph ready

You can receive a notification immediately after the task execution graph has been populated.

You can also add a link:{javadocPath}/org/gradle/api/execution/TaskExecutionGraphListener.html[TaskExecutionGraphListener] to the link:{javadocPath}/org/gradle/api/execution/TaskExecutionGraph.html[TaskExecutionGraph] to receive these events.

[[sec:task_execution]]
=== Task execution

You can receive a notification immediately before and after any task is executed.

The following example logs the start and end of each task execution. Notice that the `afterTask` notification is received regardless of whether the task completes successfully or fails with an exception.

.Logging of start and end of each task execution
====
include::sample[dir="snippets/buildlifecycle/taskExecutionEvents/groovy",files="build.gradle[]"]
include::sample[dir="snippets/buildlifecycle/taskExecutionEvents/kotlin",files="build.gradle.kts[]"]
====

==== Output of **`gradle -q broken`**
[source.multi-language-sample,groovy]
----
> gradle -q broken
include::{snippetsPath}/buildlifecycle/taskExecutionEvents/tests-groovy/taskExecutionEvents.groovy.out[]
----
[source.multi-language-sample,kotlin]
----
> gradle -q broken
include::{snippetsPath}/buildlifecycle/taskExecutionEvents/tests-kotlin/taskExecutionEvents.kotlin.out[]
----

You can also use a link:{javadocPath}/org/gradle/api/execution/TaskExecutionListener.html[TaskExecutionListener] to the link:{javadocPath}/org/gradle/api/execution/TaskExecutionGraph.html[TaskExecutionGraph] to receive these events.

[[sec:configuration_and_execution_phase]]
== Configuration and execution phase

It is important to keep in mind that Gradle has a distinct configuration and execution phase (see <<build_lifecycle.adoc#build_lifecycle,Build Lifecycle>>).

.Distinct configuration and execution phase
====
include::sample[dir="snippets/tutorial/mkdirTrap/groovy", files="build.gradle[]"]
include::sample[dir="snippets/tutorial/mkdirTrap/kotlin", files="build.gradle.kts[]"]
====

.Output of **`gradle -q compile`**
----
> gradle -q compile
include::{snippetsPath}/tutorial/mkdirTrap/tests/mkdirTrap.out[]
----

As the creation of the directory happens during the configuration phase, the `clean` task removes the directory during the execution phase.


<<build_lifecycle.adoc#sec:build_phases,Build phases>> describe the phases of every Gradle build.
Let's zoom into the configuration and execution phases of a multi-project build.
Configuration here means evaluating the build script file of a project, which includes downloading all plugins and build script dependencies.
By default, the configuration of all projects happens before any task is executed.
This means that when a single task, from a single project is requested, _all_ projects of a multi-project build are configured first.
The reason every project needs to be configured is to support the flexibility of accessing and changing any part of the Gradle project model.

[[sec:parallel_execution]]
== Parallel project execution

With more and more CPU cores available on developer desktops and CI servers, it is important that Gradle is able to fully utilise these processing resources.
More specifically, parallel execution attempts to:

* Reduce total build time for a multi-project build where execution is IO bound or otherwise does not consume all available CPU resources.
* Provide faster feedback for execution of small projects without awaiting completion of other projects.

Although Gradle already offers parallel test execution via link:{javadocPath}/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks-int-[Test.setMaxParallelForks(int)] the feature described in this section is parallel execution at a project level.

Parallel project execution allows the separate projects in a decoupled multi-project build to be executed in parallel (see also <<#sec:decoupled_projects,Decoupled projects>>).
While parallel execution does not strictly require decoupling at configuration time, the long-term goal is to provide a powerful set of features that will be available for fully decoupled projects.
Such features include:

* <<#sec:configuration_on_demand,Configuration on-demand>>.
* Configuration of projects in parallel.
* Re-use of configuration for unchanged projects.
* Project-level up-to-date checks.
* Using pre-built artifacts in the place of building dependent projects.


How does parallel execution work? First, you need to tell Gradle to use parallel mode.
You can use the <<command_line_interface.adoc#sec:command_line_performance,`--parallel` command line argument>> or configure your build environment (<<build_environment.adoc#sec:gradle_configuration_properties,Gradle properties>>).
Unless you provide a specific number of parallel threads, Gradle attempts to choose the right number based on available CPU cores.
Every parallel worker exclusively owns a given project while executing a task.
Task dependencies are fully supported and parallel workers will start executing upstream tasks first.
Bear in mind that the alphabetical ordering of decoupled tasks, as can be seen during sequential execution, is not guaranteed in parallel mode.
In other words, in parallel mode tasks will run as soon as their dependencies complete _and a task worker is available to run them_, which may be earlier than they would start during a sequential build.
You should make sure that task dependencies and task inputs/outputs are declared correctly to avoid ordering issues.

[[sec:decoupled_projects]]
== Decoupled Projects

Gradle allows any project to access any other project during both the configuration and execution phases.
While this provides a great deal of power and flexibility to the build author, it also limits the flexibility that Gradle has when building those projects.
For instance, this effectively prevents Gradle from correctly building multiple projects in parallel, configuring only a subset of projects, or from substituting a pre-built artifact in place of a project dependency.

Two projects are said to be _decoupled_ if they do not directly access each other's project model.
Decoupled projects may only interact in terms of declared dependencies: <<declaring_dependencies.adoc#sub:project_dependencies,project dependencies>> and/or <<tutorial_using_tasks.adoc#sec:task_dependencies,task dependencies>>.
Any other form of project interaction (i.e. by modifying another project object or by reading a value from another project object) causes the projects to be coupled.
The consequence of coupling during the configuration phase is that if gradle is invoked with the 'configuration on demand' option, the result of the build can be flawed in several ways.
The consequence of coupling during execution phase is that if gradle is invoked with the parallel option, one project task runs too late to influence a task of a project building in parallel.
Gradle does not attempt to detect coupling and warn the user, as there are too many possibilities to introduce coupling.

A very common way for projects to be coupled is by using <<sharing_build_logic_between_subprojects#sec:convention_plugins_vs_cross_configuration,configuration injection>>.
It may not be immediately apparent, but using key Gradle features like the `allprojects` and `subprojects` keywords automatically cause your projects to be coupled.
This is because these keywords are used in a `build.gradle` file, which defines a project.
Often this is a “root project” that does nothing more than define common configuration, but as far as Gradle is concerned this root project is still a fully-fledged project, and by using `allprojects` that project is effectively coupled to all other projects.
Coupling of the root project to subprojects does not impact <<#sec:configuration_on_demand,configuration on-demand>>, but using the `allprojects` and `subprojects` in any subproject's `build.gradle` file will have an impact.

This means that using any form of shared build script logic or configuration injection (`allprojects`, `subprojects`, etc.) will cause your projects to be coupled.
As we extend the concept of project decoupling and provide features that take advantage of decoupled projects, we will also introduce new features to help you to solve common use cases (like configuration injection) without causing your projects to be coupled.

In order to make good use of cross project configuration without running into issues for parallel and 'configuration on demand' options, follow these recommendations:

* Avoid a subproject's build script referencing other subprojects; preferring cross configuration from the root project.
* Avoid changing the configuration of other projects at execution time.


[[sec:configuration_on_demand]]
== Configuration on demand

The _Configuration injection_ feature and access to the complete project model are possible because every project is configured before the execution phase.
Yet, this approach may not be the most efficient in a very large multi-project build.
There are Gradle builds with a hierarchy of hundreds of subprojects.
The configuration time of huge multi-project builds may become noticeable.

Configuration on demand attempts to configure only projects that are relevant for requested tasks, i.e. it only executes the build script file of projects that are participating in the build.
This way, the configuration time of a large multi-project build can be reduced.

The configuration on demand feature is incubating, so not every build is guaranteed to work correctly.
The feature should work very well for multi-project builds that have <<#sec:decoupled_projects,decoupled projects>>.
In “configuration on demand” mode, projects are configured as follows:

* The root project is always configured.
* The project in the directory where the build is executed is also configured, but only when Gradle is executed without any tasks.
This way the default tasks behave correctly when projects are configured on demand.
* The standard project dependencies are supported and makes relevant projects configured.
If project A has a compile dependency on project B then building A causes configuration of both projects.
* The task dependencies declared via task path are supported and cause relevant projects to be configured.
Example: `someTask.dependsOn(":some-other-project:someOtherTask")`
* A task requested via task path from the command line (or Tooling API) causes the relevant project to be configured.
For example, building 'project-a:project-b:someTask' causes configuration of project-b.

To configure on demand with every build run see <<build_environment.adoc#sec:gradle_configuration_properties,Gradle properties>>.
To configure on demand just for a given build, see <<command_line_interface.adoc#sec:command_line_performance,command-line performance-oriented options>>.
