// Copyright 2022 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
[[multi_project_builds]]
= Project Structure

If you are building a software of a certain size with Gradle, you have two basic structuring mechanisms.
First, this chapter describes how to structure your software project using a Gradle multi-project.
In this documentation, we consider this to be a single _software component_ which is structured internally.
Second, you may regard your software as a _software product_ that is composed of multiple _software components_ where each component is represented by a separate Gradle build.
This is described in detail in the chapter on <<structuring_software_products.adoc#structure_large_projects,structuring software products with Gradle>>

[[sec:creating_multi_project_builds]]
== Creating a multi-project build

A multi-project build in Gradle consists of one root project, and one or more subprojects.

A basic multi-project build contains a root project and a single subproject.
This is a structure of a multi-project build that contains a single subproject called `app`:

.Basic multi-project build
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── app
│   ...
│   └── build.gradle
└── settings.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── app
│   ...
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
====

This is the recommended project structure for starting any Gradle project.
The <<build_init_plugin#build_init_plugin,build init plugin>> also generates skeleton projects that follow this structure - a root project with a single subproject.

Note that the root project does not have a Gradle build file, only a settings file that defines the subprojects to include.
====
include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="settings.gradle[]"]
include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="settings.gradle.kts[]"]
====

In this case, Gradle will look for a build file in the `app` directory.

We can view the structure of a multi-project build by running the `gradle projects` command.
----
> gradle -q projects
include::{snippetsPath}/multiproject/basic-multiproject/tests/projects.out[]
----

Let's say the `app` subproject is a Java application by applying the <<application_plugin#application_plugin,application plugin>> and configuring the main class:
====
include::sample[dir="snippets/multiproject/basic-multiproject/groovy",files="app/build.gradle[]"]
include::sample[dir="snippets/multiproject/basic-multiproject/kotlin",files="app/build.gradle.kts[]"]
.app/src/main/java/com/example/Hello.java
[source, java]
----
include::{snippetsPath}/multiproject/basic-multiproject/groovy/app/src/main/java/com/example/Hello.java[]
----
====

We can then run the application by executing the `run` task from the <<application_plugin#application_plugin,application plugin>>.
----
> gradle -q run
include::{snippetsPath}/multiproject/basic-multiproject/tests/run.out[]
----

And that's how simple it is to create a basic multi-project build.

[[sec:adding_subprojects]]
== Adding subprojects

Let's say we want to add another subproject called `lib` to the previously created project.
All we need to do is add another `include` statement in the root settings file:
====
include::sample[dir="snippets/multiproject/multiple-subprojects/groovy",files="settings.gradle[]"]
include::sample[dir="snippets/multiproject/multiple-subprojects/kotlin",files="settings.gradle.kts[]"]
====

Gradle will then look for the build file for the new subproject in the `lib/` subdirectory of the project:

.Multi-project build with two subprojects
====
[.multi-language-sample]
=====
.Project layout
[source, groovy]
----
.
├── app
│   ...
│   └── build.gradle
├── lib
│   ...
│   └── build.gradle
└── settings.gradle
----
=====
[.multi-language-sample]
=====
.Project layout
[source, kotlin]
----
.
├── app
│   ...
│   └── build.gradle.kts
├── lib
│   ...
│   └── build.gradle.kts
└── settings.gradle.kts
----
=====
====


Next, will explore how build logic can be <<sharing_build_logic_between_subprojects#sharing_build_logic_between_subprojects,shared between subprojects>>
and how subprojects can <<declaring_dependencies_between_subprojects#declaring_dependencies_between_subprojects,depend on one another>>.

== Naming recommendations

As your project grows, naming and consistency gets increasingly more important.
To keep your builds maintainable, we recommend the following:

1. _Keep default project names for subprojects_:
It is possible to configure custom project names in the settings file.
However, it’s an unnecessary extra effort for the developers to keep track of which project belongs to what folders.

2. _Use kebab case formatting for all project names_:
A kebab case formatting is when all letters lowercase, words separated with a dash (‘-’) character (e.g.`kebab-case-formatting`).
This is already the de-facto pattern for many large projects.
Besides, Gradle supports <<command_line_interface.adoc#sec:name_abbreviation,name abbreviation for kebab case names>>.

3. _Define the root project name in the settings file_:
The ´rootProject.name´ effectively assigns a name to the build as a whole, which is used in reports like build scans.
If the root project name is not set, the name will be the container directory name, which can be unstable (i.e. you can check out your project to any directory).

[[fine_tuning_project_layout]]
= Fine Tuning the Project Layout

A multi-project build is a build where you build more than one project during a single execution of Gradle.
You have to declare the projects taking part in the multi-project build in the settings file.

[[sub:project_locations]]
== Project locations

Multi-project builds are always represented by a tree with a single root.
Each element in the tree represents a project.
A project has a path which denotes the position of the project in the multi-project build tree.
In most cases the project path is consistent with the physical location of the project in the file system.
However, this behavior is configurable. The project tree is created in the `settings.gradle` file.
The location of the settings file is also the location of the root project.

[[sub:building_the_tree]]
== Building the tree

In the settings file you can use the `include` method to build the project tree.

.Project layout
====
include::sample[dir="snippets/multiproject/standardLayouts/groovy",files="settings.gradle[tags=hierarchical-layout]"]
include::sample[dir="snippets/multiproject/standardLayouts/kotlin",files="settings.gradle.kts[tags=hierarchical-layout]"]
====

The `include` method takes project paths as arguments.
The project path is assumed to be equal to the relative physical file system path.
For example, a path 'services:api' is mapped by default to a folder 'services/api' (relative from the project root).
You only need to specify the leaves of the tree.
This means that the inclusion of the path 'services:hotels:api' will result in creating 3 projects: 'services', 'services:hotels' and 'services:hotels:api'.
More examples of how to work with the project path can be found in the DSL documentation of link:{groovyDslPath}++/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])++[Settings.include(java.lang.String[\])].


[[sub:modifying_element_of_the_project_tree]]
== Modifying elements of the project tree

The multi-project tree created in the settings file is made up of so called _project descriptors_.
You can modify these descriptors in the settings file at any time.
To access a descriptor you can do:

.Lookup of elements of the project tree
====
include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=lookup-project]"]
include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=lookup-project]"]
====

Using this descriptor you can change the name, project directory and build file of a project.

.Modification of elements of the project tree
====
include::sample[dir="snippets/multiproject/customLayout/groovy",files="settings.gradle[tags=change-project]"]
include::sample[dir="snippets/multiproject/customLayout/kotlin",files="settings.gradle.kts[tags=change-project]"]
====

Look at the link:{javadocPath}/org/gradle/api/initialization/ProjectDescriptor.html[ProjectDescriptor] class in the API documentation for more information.

[[structure_large_projects]]
== Structuring Large Projects

As software projects grow, it is common to organize large systems into components that are connected following a certain software architecture.
Usually, it makes sense to also organize the artifacts (source code etc.) that make up the software in repositories and folder structures that reflect component boundaries and architecture.
If Gradle is used to build such a software system, it can help you to perform this organisation and enforce boundaries between components.

You can look at Gradle as a modelling tool for your software:
It allows you to describe the coarse grained structure and architecture of your software in a model written in Gradle's DSLs.
The build tool Gradle can then interpret this model to build the software.

== An example

How you architect your software and how you divide it into components depends on what you are building.
There is no one-fits-all solution.
Hence, Gradle does not enforce a particular structure on you, but rather offers the tools to model your individual setup.

Still, to exemplify these features, we explore a sample project with the following architecture:

image::software_architecture.png[]

[NOTE]
You can download link:../samples/sample_structuring_software_projects.html[the full sample] to explore, build and run it.

The structure follows a typical setup that can be found in similar form in many commonly used software architectures.

- At the bottom we define our domain model.
There are two components:
a _domain-model_ component contains the model definition (i.e. a set of data classes) and
a _state_ component is responsible for managing a modifiable state of the model during application runtime.
- On top of the model, business logic for different features is implemented independently of each other and independently of a concrete application technology.
In this example, we have two features: _user_ and _admin_.
- At the top, we have concrete applications users use to interact with the features.
In the example, we build a Spring Boot application that supports both features via a web browser.
And an Android app that only supports the _user_ feature.

Our components may rely on existing components that are retrieved from binary repositories.
For example, the Spring Boot and Android frameworks.

Apart from the production code, there are also components that deal with building and delivering the product:

- The _build-logic_ component contains the configuration details about building the software.
For example, defining a Java version to use or configuring a test framework.
It may also contain additional build logic for Gradle (<<custom_plugins.adoc#custom_plugins,custom plugins>> with <<custom_tasks.adoc#custom_tasks,custom tasks>>) that is not covered by commonly available Gradle plugins.
- The _platforms_ component is a central place to define which versions of external components are to be used in all of our own components.
By that, it defines the constraints for the environments – that is, _the platforms_ – to build, test and run the software product.
- The _aggregation_ component contains the setup of the delivery pipeline that is required to push the product to production and
doing automated end-to-end testing as part of that.
Basically, this is the part of the build that is not required on local development machines.

[NOTE]
The domain of our example is to build a tool to inform people about link:https://gradle.org/releases/[Gradle Build Tool releases].
Concretely, the application lists Gradle releases with links to release notes (_user_ feature) and
offers an administration interface for the range of releases to be listed (_admin_ feature).

== Reflecting software architecture in project structure

Let's look at how to implement the architecture of the sample with Gradle.
We can represent each of our _components_ as a separate _Gradle build_.
We'll get to the details of what that means and how components are connected in a bit.

Each Gradle build has its own folder.
The minimum to make these folders Gradle builds is to add an empty `settings.gradle(.kts)` file to each of them.
Let's do this for all the components we have in our software:

[source.multi-language-sample,groovy]
----
├── android-app
│   └── settings.gradle
├── server-application
│   └── settings.gradle
│
├── admin-feature
│   └── settings.gradle
├── user-feature
│   └── settings.gradle
│
├── state
│   └── settings.gradle
│
├── domain-model
│   └── settings.gradle
│
├── build-logic
│   └── settings.gradle
│
├── platforms
│   └── settings.gradle
│
└── aggregation
    └── settings.gradle
----

[source.multi-language-sample,kotlin]
----
├── android-app
│   └── settings.gradle.kts
├── server-application
│   └── settings.gradle.kts
│
├── admin-feature
│   └── settings.gradle.kts
├── user-feature
│   └── settings.gradle.kts
│
├── state
│   └── settings.gradle.kts
│
├── domain-model
│   └── settings.gradle.kts
│
├── build-logic
│   └── settings.gradle.kts
│
├── platforms
│   └── settings.gradle.kts
│
└── aggregation
    └── settings.gradle.kts
----

In the listing, each component lives in a separate folder.
Here we arrange them as a flat list in a root folder.
This root folder can be used as root of a Git repository for example.

This is only the setup of the sample.
You can freely choose where to physically locate your components.
For instance, you can group all components that live in one "layer" in a common subfolder.
Or, since these are all independent Gradle builds, you can have each component live in a separate repository.
It's up to you to decide what works best for you, the software you are building, and the teams working on it.

== Defining an inner structure for components

Before we get to the topic of connecting the components, let's first look at them individually.

So far, each component is just an empty folder with an empty `settings.gradle(.kts)` file indicating that this is a component Gradle can work with in some form.
To fill the component with content, you should define at least one project (referred to as subproject in Gradle's DSLs) in it.

You can start with components consisting of a single project each, but introduce additional projects later to structure a single component more internally.
In our sample, we start with a single project in each component.

A project is added by using the `include()` construct in the settings file.

.Use include() to add a project to a component
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="domain-model/settings.gradle[tags=include]"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="domain-model/settings.gradle.kts[tags=include]"]
====

Once included, you may create a folder matching the project name and create a `build.gradle(.kts)` file in it to configure that part of the component.
You can find more information in the chapter about <<multi_project_builds.adoc#multi_project_builds,structuring Gradle builds for a single software component>>.

== Assigning types to components

Let's zoom into the _domain-model_ component:

[source.multi-language-sample,groovy]
----
└── domain-model              <-- component
    ├── settings.gradle       <-- define inner structure of component and where to locate other components
    └── release               <-- project in component
        └── build.gradle      <-- defines type of the project and its dependencies
----

[source.multi-language-sample,kotlin]
----
└── domain-model              <-- component
    ├── settings.gradle.kts   <-- define inner structure of component and where to locate other components
    └── release               <-- project in component
        └── build.gradle.kts  <-- defines type of the project and its dependencies
----

Initially, `release/build.gradle(.kts)` is empty.
The project is of no specific type and does not offer any useful content.
If we add more files to the `domain-model/release` folder now, for example Java source files, Gradle won't know what to do with these files and will just ignore them.
We need to assign a type to the project to make Gradle aware of the purpose of such files.

In Gradle, you assign a type to a project by <<plugins.adoc#plugins,applying a plugin>>.
The simplest thing you can do is to apply one of Gradle's core plugins, like `base` or `java-library`.

However, usually you have additional configuration to do in the context of the product you are building.
For example, if your project should be a "Java Library", it would not only apply the `java-library` plugin but also configure details such as setting the Java version to 11.
You can add details like that directly in `release/build.gradle(.kts)` but than you would have to repeat them in other components that also contain "Java Library" projects.

Thus, the recommendation is to start using custom project types right away:

.Assign the custom type `com.example.java-library` to a project in the `user-feature` component
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="user-feature/data/build.gradle[tags=project-type]"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="user-feature/data/build.gradle.kts[tags=project-type]"]
====
.Assign the custom type `com.example.kotlin-library` to a project in the `domain-model` component
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="domain-model/release/build.gradle[tags=project-type]"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="domain-model/release/build.gradle.kts[tags=project-type]"]
====

As stated above, a project type is represented by a plugin in Gradle.
We thus define custom project types, such as `com.example.java-library` and `com.example.kotlin-library`, as plugins.
The next section explains how to define such plugins.

== Defining custom project types as convention plugins

Where do we get `com.example.kotlin-library` plugin from?
This is what our `build-logic` component is for.

The `build-logic` component contains project types that Gradle itself understands as build configuration.
That is, Gradle plugins for your specific needs, which we call _convention plugins_.

Currently, there are different project types you can use to define _convention plugins_ depending on which tools and languages you prefer.
In general, any JVM language (Java, Groovy, Kotlin, Scala) can be used to write Gradle plugins as classes that implement the `Plugin<Project>` interface.
The most compact way however, is to write them as scripts in Gradle's Groovy or Kotlin DSL.

Which method you choose is up to you.
If you are familiar with one of Gradle's DSLs you may choose that, as it is the most compact way to write _convention plugins_.
If you are new to Gradle (and also new to Groovy and Kotlin) you may prefer to write the _convention plugins_ in Java or another language like Scala.
Then you reduce the interaction with Gradle's Groovy or Kotlin DSL to a minimum.

You need to use one of the following project types (i.e. Gradle core plugins) in projects of your `build-logic` component:

- `kotlin-dsl` – Build logic projects with this type (i.e., that apply the `kotlin-dsl` plugin) allow you to write convention plugins as `.gradle.kts` files in `src/main/kotlin`.
- `groovy-gradle-plugin` – Build logic projects with this type (i.e., that apply the `groovy-gradle-plugin` plugin) allow you to write convention plugins as `.gradle` files in `src/main/groovy`.
- `java-gradle-plugin` – Build logic projects with this type (i.e., that apply the `java-gradle-plugin` plugin) allow you to write convention plugins as `.java` classes that implement the `Plugin<Project>` interface in `src/main/java`.
If you apply other JVM language plugins on top, like `groovy`, `scala` or `org.jetbrains.kotlin.jvm`, you can also write the plugin class in the corresponding language.

In our sample, we choose the option of using Gradle's DSLs for the convention plugins.
The `build-logic` component has several projects that each define a project type through a convention plugin - one of:
`java-library`, `kotlin-library`, `spring-application`, `android-application`.
Also, there is a project called `commons` for build configuration shared by all our project types.

.Assign a custom type to a component's project by applying a convention plugin
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="build-logic/spring-boot-application/build.gradle"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="build-logic/spring-boot-application/build.gradle.kts"]
====

Looking at the `build.gradle(.kts)` of the `build-logic` project for spring boot applications, we see:

<1> That it is of type `groovy-gradle-plugin` or `kotlin-dsl` to allow convention plugins written in the corresponding DSL
<2> It depends on our own `plugins-platform` from the `platforms` component
<3> It depends on the `commons` project from `build-logic` to have access to our own commons convention plugin
<4> It depends on the Spring Boot Gradle plugin from the Gradle Plugin Portal so that we may apply that plugin to our Spring Boot projects

Now, we can write the convention plugin for Spring application like this:

.Defining a custom project type as convention plugin
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="build-logic/spring-boot-application/src/main/groovy/com.example.spring-boot-application.gradle"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="build-logic/spring-boot-application/src/main/kotlin/com.example.spring-boot-application.gradle.kts"]
====

We see that we apply our own `com.example.commons` plugin which is another convention plugin that, among other things, configures the Java version we are targeting and adds a dependency to a platform (`com.example.platform:product-platform` from our `platforms` component).
And we apply the spring boot plugin.
Furthermore, we add two dependencies that Spring Boot projects should always have in our context.

Similarly, we define convention plugins for "Java Libraries", "Kotlin Libraries" and "Android Applications".
With that, we have four different project types defined that we assign to the projects of our production code components.

You can find more information about writing convention plugins in section on <<sharing_build_logic_between_subprojects.adoc#sharing_build_logic_between_subprojects,sharing build logic>> and the link:../samples/sample_convention_plugins.html[associated sample].
For using classes to implement plugins, and for writing more advanced custom build logic, consult the chapter on <<custom_plugins.adoc#custom_plugins,Gradle plugin development>>.

== Connecting components

As demonstrated in the architecture figure, our production code components depend on each other.
Above, we already saw that the `platforms` component is used in the `build-logic` component.
We also said that we want to use the `build-logic` component, which declares project types through convention plugins,
to assign those types to the projects in our production code components.

How do you define these dependencies?
There are two distinct things to do:

1. _Make components (builds) known to each other._ This is done by adding `includeBuild(...)` statements to `settings.gradle(.kts)`.
This is _not_ adding a dependency between (projects of) components.
It just makes the physical location of one component known to another.
In that sense it is similar to repository declarations to discover binary components.
Consult <<composite_builds.adoc#defining_composite_builds,the section on defining composite builds>> for more information about how to include builds.
2. _Declare dependencies between (projects of) components._
This is done similarly to <<declaring_dependencies.adoc#declaring-dependencies,declaring dependencies to binary components>> by using GA (_group_ and _artifact_) coordinates in the `dependencies { }` block of a `build.gradle(.kts)` file:
`implementation("com.example.platform:product-platform")`.
Or, if the included component provides a plugin, you <<plugins.adoc#sec:plugins_block,apply the plugin by ID>> similar to how you would apply a plugin from the plugin portal:
`plugins { id("com.example.java-library") }`

As another example, consider the setup of our `server-application` component:

.Defining component locations and inner structure of the `server-application` component
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="server-application/settings.gradle"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="server-application/settings.gradle.kts"]
====

We see that the `settings.gradle(.kts)` file only defines location for build logic components, other production code components and the inner structure of the component.
Only the `build.gradle(.kts)` file in the `app` project then defines actual dependencies by applying a convention plugin and utilizing the _dependencies_ block.

.Configuring type and dependencies of the `app` project inside the `server-application` component
====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="server-application/app/build.gradle"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="server-application/app/build.gradle.kts"]
====

== The model of your software

That's it.
This chapter gave an overview of which techniques to use to structure a software project into components with Gradle by following a sample.
Download link:../samples/sample_structuring_software_projects.html[the full sample] to explore further details.
The <<structuring_software_products_details.adoc#tweaking_structure,next chapter>> covers more details about how to work with and evolve this kind of project structure.
The <<composite_builds.adoc#composite_builds,chapter on composite builds>> gives you more technical background about the capabilities build composition offers.

To summarize, if you follow the suggestions from this chapter, your setup should clearly separate the following concerns to give you a flexible and clean model of your software product:

1. _Write compact `build.gradle(.kts)` files._
   While in traditional Gradle builds these files tend to grow and mix a lot of different concerns, the structure presented here keeps these files compact.
   In most cases they only declare a project type by applying a single convention plugin and dependencies in the `dependencies {}` block.
   They might include minimal project-specific configuration, but these should be kept as minimal as possible.
   This also makes builds less dependent on Gradle's DSLs: If you put your build logic into convention plugins, you can write it directly in Java if you like.
2. _Isolate cross-cutting technical concerns into project types._
   Technically motivated build configuration often cuts across the entire software architecture.
   Whether or not a project is a "Java Library" or "Kotlin Library" may be totally independent of where it is located in the hierarchy of your components.
   If you use convention plugins, this allows you to isolate the definition of such project types in a central place, while still reusing them wherever needed.
   (This is a huge advantage over so called <<sharing_build_logic_between_subprojects.adoc#sec:convention_plugins_vs_cross_configuration,cross project configuration>>, which has been popular with older Gradle versions, but is bound to the hierarchy of your project.)
3. _Declare the origins of components in a central place._
   In this structure, the places where a build can find other components, independent of whether they are <<declaring_repositories.adoc#sub:centralized-repository-declaration,located in a binary repository>> or are <<composite_builds.adoc#settings_defined_composite,available locally as other Gradle builds>>, are defined centrally in the `settings.gradle(.kts)` file.
   This makes it easy to change the origin of a component and <<structuring_software_products_details.adoc#binary_vs_source_components,move from a binary to a from-source version of a component>>.
   Note that <<structuring_software_products_details.adoc#settings_convention_plugins,there are different strategies to avoid duplicating this information>> in each `settings.gradle(.kts)` of each of your components.
4. _Declare platforms in a central place._
   Having a platform component as in the example is optional.
   You could do things without one of these, e.g. by declaring <<dependency_constraints.adoc#dependency-constraints,dependency constraints>> directly in your convention plugins.
   However, <<platforms.adoc#sec:sharing-dep-versions-between-projects,platforms>> are a good option to ensure all the boundaries for the environment in which your software operates defined in a central place.

[[tweaking_structure]]
== Working with the software project

You have several options to interact with a build that is a composition of multiple builds.

=== Using an umbrella build

If all your builds are located in one folder structure, you can have an umbrella build in a root folder that includes all builds.
You can then <<composite_builds.adoc#composite_build_executing_tasks,call tasks from the root project by addressing one of the builds>>.
Usually, you would then put the <<gradle_wrapper.adoc#sec:adding_wrapper,Gradle wrapper>> into the root as well.
link:../samples/sample_structuring_software_projects.html[The sample]
on structuring software projects contains such an umbrella build in the root.
You can address tasks from there:

[listing.terminal.sample-command]
----
$ ./gradlew :server-application:app:bootRun

$ ./gradlew :android-app:app:installDebug
----

The umbrella build is a good place to define cross-build  <<more_about_tasks.adoc#sec:lifecycle_tasks,lifecycle tasks>>.
For example, you can define a `checkFeatures` task for conveniently running all checks in selected components by adding a `build.gradle(.kts)` file to your umbrella build.

====
include::sample[dir="samples/build-organization/structuring-software-projects/groovy",files="build.gradle"]
include::sample[dir="samples/build-organization/structuring-software-projects/kotlin",files="build.gradle.kts"]
====

In your IDE, you can import the umbrella build and then will have all Gradle builds as projects/modules visible in the workspace.

=== Working with components in isolation

Independent of whether you have an umbrella build or not, you can work with each component independently.
That is, you can pick any component build and build it individually.

In link:../samples/sample_structuring_software_projects.html[the sample], the umbrella build is a convenience.
The whole project can also be used without it, if you work with the components independently.

[listing.terminal.sample-command]
----
$ cd server-application
$ ../gradlew :app:bootRun

$ cd android-app
$ ../gradlew :app:installDebug

$ cd user-feature
$ ../gradlew check
----

You can also import components independently in the IDE.
This allows you to focus only on the parts important for the component you work on in your IDE's workspace.
It might also speed up the IDE performance in the case of a very large code base.

[NOTE]
====
If all components live in the same repository, you should only have one <<gradle_wrapper.adoc#sec:adding_wrapper,Gradle wrapper>> in the root of the repository.
If you have an umbrella build there, you can use that to manage the wrapper.

However, if you import an individual component in an IDE, it might have issues finding the wrapper and you might need to configure a Gradle installation manually.

If your components are scattered over multiple repositories, each should have its own wrapper, but you should ensure that you upgrade them simultaneously.
====

== Using multiple source repositories

Multi-repo development is a well known alternative to mono-repo development.
Both have advantages and disadvantages.
It depends on many different factors which setup works best for the development of your product.

Gradle aims to support both setups equally well.
When you split your product into components, each represented by an independent build, switching a Gradle build between mono- and multi-repo development is simple.
In mono-repo development, you put all builds under a common root.
In multi-repo development, you place each build into a separate source repository.

Multi-repo development possibly needs some additional guidlines and tooling, so that builds can still find each other.
A simple solution is that users who want to build a certain component need to clone all repositories of dependent components next to each other in a file hierarchy.
If you follow this pattern, builds can find each other with `includeBuild("../other-component")` statements.
If locations are more flexible, you can also <<composite_builds.adoc#command_line_composite,invoke Gradle with `--include-build` flags>> to provide locations dynamically.

Another more evolved setup can involve versioning all components and, instead of including the source versions of all components, depend on published versions of them from binary repositories.
This is described next.

[[binary_vs_source_components]]
== Publishing and using binary components

You can also decide to <<publishing_setup.adoc#publishing_components,publish your components to a binary repository>>.
If you make the decision to do so at some point and you want to work with binary versions of certain components instead of the source versions, you can do that by
<<declaring_repositories.adoc#sub:centralized-repository-declaration,adding the repository to which you published>> instead of the corresponding `includeBuild("...")` statements in your `settings.gradle(.kts)` file.
If the components keep their coordinates, you do not need to adjust any dependencies.
You just need to define versions for the components, ideally in a <<platforms.adoc#sec:sharing-dep-versions-between-projects,platform project>>.

[[publish-convention-plugins]]
=== Publishing components with convention plugins

Note that when publishing build logic components, the `maven-publish` will also publish so called <<plugins.adoc#sec:plugin_markers,plugin markers>> that allow Gradle to find plugins by ID – even if they are located in a repository.
For that you only need to <<publishing_gradle_plugins.adoc#custom-plugin-repositories,declare the repositories you want to publish to>> in your build the same way you do it for other components.

[[settings_convention_plugins]]
== Sharing repository and included build declarations between builds

Each component build has its own `settings.gradle(.kts)` file to describe the location of other components.
Which is done by declaring repositories with binary components and by declaring file system locations of included builds.

If components are developed independently, it often makes sense to define these individually for each one.
Then it is individually controlled where the other components originate from.
Furthermore, the declarations might vary from build to build.
For example, you might only include the builds that are needed to build a certain component and not all builds that make up the product.

However, it may also lead to redundancy as you declare the same repositories and included builds in each `settings.gradle(.kts)` file again.
In particular, if all builds live in the same repository.

Similar as for build scripts, you can define _settings convention plugins_ for the `settings.gradle(.kts)` file to reuse configuration.
For that, you should create a separate build.
_Settings convention plugins_ can be <<custom_plugins.adoc#sec:precompiled_plugins,written in Groovy DSL or Kotlin DSL similar to other convention plugins>>.
The script file name has to end with `.settings.gradle(.kts)`.
A build providing a settings plugin needs to be <<composite_builds.adoc#included_plugin_builds,included as plugin builds in the `pluginManagement {}` block>>.
