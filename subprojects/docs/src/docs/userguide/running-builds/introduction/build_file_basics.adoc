// Copyright 2023 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[build_file_basics]]
= Build File Basics

Every project has a build script that details build configuration, tasks, and plugins.

image::gradle-basic-4.png[]

Every Gradle build comprises one or more projects; a root project and subprojects.
Each one has a _build script_.

For single-project builds, the build file contains dependencies and repository information for the build and the project.

For multi-project builds, each subproject has its own build file, and each subproject will be evaluated by executing its build file.

In the build file, two types of dependencies can be added:

1. The libraries and/or plugins on which Gradle and the build script depend.
2. The libraries on which the project sources depend.

[[sec:build_script]]
== Build scripts

The build script is either a `build.gradle` file written in Groovy or a `build.gradle.kts` file written in Kotlin.

The link:{groovyDslPath}/index.html[Groovy DSL^] and the link:{kotlinDslPath}/index.html[Kotlin DSL^] are the only accepted languages for Gradle scripts.

Let's take a look at an example of a simple Java app and break it down:

====
[.multi-language-sample]
=====
.settings.gradle.kts
[source,kotlin]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.0"                      // <1>
    application
}

repositories {
    mavenCentral()                                                      // <2>
}

dependencies {
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")       // <3>
    testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    implementation("com.google.guava:guava:32.1.1-jre")
}

application {
    mainClass.set("main")                                               // <4>
}

tasks.named<Test>("test") {
    useJUnitPlatform()                                                  // <5>
}
----
<1> Apply the plugin to add support for Kotlin and Java (via the application).
<2> Use Maven Central for resolving dependencies.
<3> Use the JUnit 5 integration and a dependency from Google used by the application.
<4> Define the main class for the application.
<5> Use JUnit Platform for unit tests.
=====

[.multi-language-sample]
=====
.settings.gradle
[source,groovy]
----
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.0'                       // <1>
    id 'application'
}

repositories {
    mavenCentral()                                                      // <2>
}

dependencies {
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit5'        // <3>
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.9.3'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'com.google.guava:guava:32.1.1-jre'
}

application {
    mainClass = 'main'                                                  // <4>
}

tasks.named('test') {
    useJUnitPlatform()                                                  // <5>
}
----
<1> Apply the plugin to add support for Kotlin and Java (via the application).
<2> Use Maven Central for resolving dependencies.
<3> Use the JUnit 5 integration and a dependency from Google used by the application.
<4> Define the main class for the application.
<5> Use JUnit Platform for unit tests.
=====
====

=== 1. Add extensions via plugins
Plugins are bundled tasks used to extend Gradle.

Adding a plugin to a build is called _applying_ a plugin.

[source]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.0"
    application
}
----

Since our example is a Java app, the `application` plugin, which is included with Gradle, has been applied, adding Java support and more.

The Kotlin gradle plugin, version 1.9.0, has also been applied since our app contains Kotlin code.

=== 2. Add dependency location
A project generally has several dependencies it needs to do its work.
Many of the dependencies will be used by the source code.

In the example, the link:https://mvnrepository.com/[Maven Central^] repository has been added as the location for all the binary plugins that Gradle will need to download to build the project.

[source]
----
repositories {
    mavenCentral()
}
----

=== 3. Add dependencies
Dependencies are grouped in configurations and can be retrieved and uploaded from repositories.

In the example, a list of dependencies based on configurations (how/when/where Gradle will use it) is added, including the `junit` testing framework, which is used to test the Java source code.

[source]
----
dependencies {
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    implementation("com.google.guava:guava:32.1.1-jre")
}
----

=== 4. Use convention properties
A plugin adds tasks to a project.
It also adds properties and methods to a project.

In the example, the `application` plugin has a method that can declare the main class of our Java application, which is required to compile and run the code.

[source]
----
application {
    mainClass.set("main")
}
----

=== 5. Create or update tasks
Tasks perform some basic work, such as compiling classes, running unit tests, or zipping up a WAR file.

Tasks either come from plugins or the build script itself.

In the example, the build script requires all test-related tasks to use the `junit` platform.

[source]
----
tasks.named<Test>("test") {
    useJUnitPlatform()
}
----
