// Copyright 2023 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[build_file_basics]]
= Build File Basics

Every Gradle build is made up of one or more _projects_; a root project and subprojects.

For every project or subproject, there is a build script.

For single project builds, the build file contains dependencies and repository information for the build and the project.

For multi-project build, each subproject has its own build file, and each subproject will be evaluated by executing its build file.

In the build file, there are two types of dependencies that can be added:

1. The libraries and/or plugins on which Gradle and our build script is dependent.
2. The libraries on which the source code and the project is dependent to be built.

[[sec:build_script]]
== Build scripts

The build script is either a `build.gradle` file when written in Groovy or a `build.gradle.kts` file when written in Kotlin.

The link:{groovyDslPath}/index.html[Groovy DSL^] and the link:{kotlinDslPath}/index.html[Kotlin DSL^] are the only accepted languages for Gradle scripts.

Let's take a look at an example for a simple Java app and break it down:

====
[.multi-language-sample]
=====
.settings.gradle.kts
[source,kotlin]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.0"                      // <1>
    application                                                         // <2>
}

repositories {
    mavenCentral()                                                      // <3>
}

dependencies {
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")       // <4>
    testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")  // <5>
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    implementation("com.google.guava:guava:32.1.1-jre")                 // <6>
}

application {
    mainClass.set("main")                                               // <7>
}

tasks.named<Test>("test") {
    useJUnitPlatform()                                                  // <8>
}
----
<1> Apply the `org.jetbrains.kotlin.jvm` plugin to add support for Kotlin.
<2> Apply the application plugin to add support for building a CLI application in Java.
<3> Use Maven Central for resolving dependencies.
<4> Use the Kotlin JUnit 5 integration.
<5> Use the JUnit 5 integration.
<6> This dependency from Google is used by the application.
<7> Define the main class for the application.
<8> Use JUnit Platform for unit tests.
=====

[.multi-language-sample]
=====
.settings.gradle
[source,groovy]
----
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.0'                       // <1>
    id 'application'                                                    // <2>
}

repositories {
    mavenCentral()                                                      // <3>
}

dependencies {
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit5'        // <4>
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.9.3'   // <5>
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'com.google.guava:guava:32.1.1-jre'                  // <6>
}

application {
    mainClass = 'main'                                                  // <7>
}

tasks.named('test') {
    useJUnitPlatform()                                                  // <8>
}
----
<1> Apply the `org.jetbrains.kotlin.jvm` plugin to add support for Kotlin.
<2> Apply the application plugin to add support for building a CLI application in Java.
<3> Use Maven Central for resolving dependencies.
<4> Use the Kotlin JUnit 5 integration.
<5> Use the JUnit 5 integration.
<6> This dependency from Google is used by the application.
<7> Define the main class for the application.
<8> Use JUnit Platform for unit tests.
=====
====

=== Add extensions via plugins

Plugins are bundled tasks used to extend Gradle.
They are also used to modularise and reuse project configuration.

Adding a plugin to a build is called _applying_ a plugin.

[source]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.0"
    application
}
----

Since our example is a Java app, the `application` plugin, which is included with Gradle, has been applied.

The Kotlin gradle plugin, version 1.9.0 has also been applied since our app also contains Kotlin code.

=== Add dependencies and dependency location

A project generally has a number of dependencies it needs in order to do its work, typically found in the source code.

Those dependencies are grouped in configurations, and can be retrieved and uploaded from repositories.

In the example, the link:https://mvnrepository.com/[Maven Central^] repository has been added as the location for all the binary plugins that Gradle will need to download to function.

Then, a list of dependencies based on configurations (how/when/where Gradle will use it) is added, including the `junit` testing framework which is used to test the Java source code.

[source]
----
repositories {
    mavenCentral()
}

dependencies {
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    implementation("com.google.guava:guava:32.1.1-jre")
}
----

=== Use convention properties

A plugin adds tasks as well as properties and methods to a project.

In the example, the `application` plugin has a method that can declare the main class of our Java application which is required to compile and run the code.

[source]
----
application {
    mainClass.set("main")
}
----

=== Create or update tasks

Tasks performs some basic piece of work, such as compiling classes, or running unit tests, or zipping up a WAR file.

Tasks either come from plugins or the build script itself.

In the example, the build script requires that all test related tasks must use the `junit` platform.

[source]
----
tasks.named<Test>("test") {
    useJUnitPlatform()
}
----
