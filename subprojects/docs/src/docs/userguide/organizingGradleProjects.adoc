// Copyright 2017 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[organizing_gradle_projects]]
== Organizing Gradle Projects

The build logic and source code of every project should be organized in a meaningful way to improve readability and avoid common problems. This page lays out the best practices by example.

[[sec:separate_language_source_files]]
=== Separate language-specific source files

Gradle's language plugins establish conventions for finding and compiling source code. For example, a project applying the <<java_plugin,Java plugin>> will automatically compile the code in the directory `src/main/java`. The last portion of the directory path usually indicates the expected language used in the source files.

Some compilers are capable of cross-compiling different languages. The Groovy compiler can handle the scenario of mixing Java and Groovy source files located in `src/main/groovy`. It is recommended practice to create source files in the conventional directories if you work on a project that uses multiple languages.

The following source tree contains Java and Kotlin source files.

----
.
├── build.gradle
├── settings.gradle
└── src
    └── main
        ├── java
        │   └── HelloWorld.java
        └── kotlin
            └── Utils.kt
----

Separated directories for dedicated language source files helps with maintaining complex projects.

[[sec:use_standard_conventions]]
=== Use standard conventions as much as possible

All Gradle core plugins follow the software engineering paradigm convention over configuration. The plugin logic provides users with sensible defaults and standards, the conventions, in a certain context. Let’s take the <<java_plugin,Java plugin>> as an example.

* It defines the directory `src/main/java` as the default source directory for compilation.
* The output directory for compiled source code and other artifacts (like the JAR file) is `build`.

By sticking to the default conventions, new developers to the project immediately know where to find their way around. While those conventions can be reconfigured, it makes it harder to build script users and authors to manage the build logic and its outcome. Try to stick to the default conventions as much as possible.

=== Always define a setting file

Gradle tries to locate a `settings.gradle` file upon every invocation of the build. For that purpose, the runtime walks the hierarchy of the directory tree up to the root directory or if the file is found. Always add a `settings.gradle` to the root directory of your build to avoid the initial performance impact. The file can either be empty or define the desired name of the project.

[[sec:split_build_logic_functional_boundaries]]
=== Split build logic based on functional boundaries

Over time build scripts can grow large in size if you just add on to the existing logic. The middle ground between a `build.gradle` file and a binary plugin is the <<sec:script_plugins,script plugin>>. A script plugin can come in handy if you want to split the build logic along functional boundaries. Typical examples include publishing code, IDE configuration or a dedicated script plugin for declaring dependencies. It is recommended to identify portions of the build code and separate them into a script plugin.

The following example demonstrates the practice of separation of concerns to the build logic.

----
.
├── build.gradle
├── gradle
│   ├── build-scan.gradle
│   ├── ide.gradle
│   └── publishing.gradle
└── settings.gradle
----

Gradle doesn't take a stance on how to organize script plugins. However, a sensible default is to use the subdirectory `gradle`.

[[sec:build_sources]]
=== Use `buildSrc` project to abstract imperative logic

Complex build logic is usually a good candidate for being encapsulated either as custom task or binary plugins. Custom task and plugin implementations should not live in the build script. It is convenient to use `buildSrc` project as long as the code is does not need to be shared among multiple, independent projects.

The directory `buildSrc` is treated as a special project. Upon discovery of the directory, Gradle automatically compiles and tests this code and puts it in the classpath of your build script. For multi-project builds there can be only one `buildSrc` directory, which has to be in the root project directory.

`buildSrc` uses the same <<javalayout,source code conventions>> applicable to Java and Groovy projects. It also provides direct access to the Gradle API. Additional dependencies can be declared in a dedicated `build.gradle` under `buildSrc`.

++++
<sample xmlns:xi="http://www.w3.org/2001/XInclude" id="customBuildSrcBuild" dir="java/multiproject" title="Custom buildSrc build script">
    <sourcefile file="buildSrc/build.gradle"/>
</sample>
++++

A typical project including `buildSrc` has the following layout.

----
.
├── build.gradle
├── buildSrc
│   └── src
│       ├── main
│       │   └── java
│       │       ├── Deploy.java
│       │       └── DeploymentPlugin.java
│       └── test
│           └── java
│               └── DeploymentPluginTest.java
├── client
├── service
├── settings.gradle
└── web
----
