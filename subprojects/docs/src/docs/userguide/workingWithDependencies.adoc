// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[working_with_dependencies]]
== Working with Dependencies

Gradle provides an extensive API for navigating, inspecting and post-processing metadata and artifacts of resolved dependencies. With this API at hand, you can implement more complex requirements to your build requiring a "runtime view" of dependencies.

The main entry point for this functionality is the api:org.gradle.api.artifacts.Configuration[] API. To learn more about the fundamentals of configurations, see <<sub:scope_of_dependency_configurations>>.

=== Iterating over dependencies assigned to a configuration

Sometimes you'll want to implement logic based on the declared dependencies of a project e.g. to inspect the declared dependencies in build script from a Gradle plugin. You can iterate over set of dependencies assigned to a configuration with the help of the method api:org.gradle.api.artifacts.Configuration#getDependencies()[]. Alternatively, you can also use api:org.gradle.api.artifacts.Configuration#getAllDependencies()[] to include the declared dependencies of <<sub:inheriting_dependencies_from_other_configurations,superconfigurations>>. The returned dependencies do not resolve the configuration and therefore do not include transitive dependencies.

++++
<sample id="iterating-dependencies" dir="userguide/dependencyManagement/workingWithDependencies/iterateDependencies" title="Iterating over the dependencies assigned to a configuration">
    <sourcefile file="build.gradle" snippet="iteration-task" />
</sample>
++++

=== Iterating over artifacts resolved for a module

None of the <<inspecting_dependencies,dependency reporting>> helps you with inspecting or further processing the underlying, resolved artifacts of a module. A typical use case for accessing the artifacts is to copy them into a specific directory or filter out files of interest based on a specific file extension.

You can iterate over the complete set of artifacts resolved for a module with the help of the method api:org.gradle.api.file.FileCollection#getFiles()[]. Every file instance returned from the method points to its location in the <<dependency_cache,dependency cache>>. Using this method on a `Configuration` instance is possible as the interface extends `FileCollection`.

++++
<sample id="iterating-artifacts" dir="userguide/dependencyManagement/workingWithDependencies/iterateArtifacts" title="Iterating over the artifacts resolved for a module">
    <sourcefile file="build.gradle" snippet="iteration-task" />
</sample>
++++

[NOTE]
====
Iterating over the artifacts of a module automatically resolves the configuration. A resolved configuration becomes immutable and cannot add or remove dependencies. If needed you can copy a configuration for further modification via api:org.gradle.api.artifacts.Configuration#copy()[].
====

=== Navigating the dependency graph

As a plugin developer, you might be faced with the challenge of navigating the full graph of dependencies assigned to a configuration e.g. for turning the dependency graph into a visualization. You can access the full graph of dependencies for a configuration with the help of the api:org.gradle.api.artifacts.result.ResolutionResult[].

The resolution result provides various methods for accessing the resolved and unresolved dependencies. For demonstration purposes the sample code uses api:org.gradle.api.artifacts.result.ResolutionResult#allDependencies(org.gradle.api.Action)[]. Each iteration of the method returns an instance of api:org.gradle.api.artifacts.result.ResolvedDependencyResult[] or api:org.gradle.api.artifacts.result.UnresolvedDependencyResult[] providing detailed information about the dependency.

++++
<sample id="walking-dependency-graph" dir="userguide/dependencyManagement/workingWithDependencies/walkGraph" title="Walking the resolved and unresolved dependencies of a configuration">
    <sourcefile file="build.gradle" snippet="walk-task" />
</sample>
++++

=== Accessing a moduleâ€™s metadata file

As part of the dependency resolution process, Gradle downloads the metadata file of a module and stores it in the dependency cache. Some organizations enforce strong restrictions on accessing repositories outside of internal network. Instead of downloading artifacts, those organizations prefer to provide an "installable" Gradle cache with all artifacts contained in it to fulfill the build's dependency requirements.

The artifact query API provides access to the raw files of a module. Currently, it allows getting a handle to the metadata file and some selected, additional artifacts (e.g. a JVM-based module's source and Javadoc files). The main API entry point is api:org.gradle.api.artifacts.query.ArtifactResolutionQuery[].

Let's say you wanted to post-process the metadata file of a Maven module. Given a configuration, you filter the component identifiers. Those component identifiers serve as input to the artifact resolution query. After executing the query, you get a handle to all components that match the criteria and their underlying files. Additionally, it's very easy to post-process the metadata file. The example code uses Groovy's link:http://docs.groovy-lang.org/latest/html/api/groovy/util/XmlSlurper.html[XmlSlurper] to ask for POM element values.

++++
<sample id="accessingMetadataArtifact" dir="userguide/dependencyManagement/workingWithDependencies/accessMetadataArtifact" title="Accessing a Maven module's metadata artifact">
    <sourcefile file="build.gradle" snippet="accessing-metadata-artifact" />
</sample>
++++
