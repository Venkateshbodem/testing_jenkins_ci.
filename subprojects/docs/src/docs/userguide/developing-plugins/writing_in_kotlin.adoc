= Writing Gradle plugins in Kotlin

In addition to <<kotlin_dsl.adoc, writing build scripts>>, Gradle also supports writing plugins in https://www.jetbrains.com/opensource/kotlin/[Kotlin].

There are multiple options to write your Kotlin plugins and multiple compatibility considerations. This page is a non-exhaustive list of dependencies and compiler configurations and their impacts in terms of compatibility and usability.

It also describes the different development plugins to help you set up these different options.


[[sec:dependencies]]
== Different dependencies

Like other JVM projects, Gradle plugins are jar files with dependencies. However,  unlike other JVM projects, Gradle provides fixed versions of some dependencies at runtime. Those dependencies are `compileOnly` dependencies and need to be compatible with the version of Gradle your plugin is running in.

If you are writing convention plugins, this is usually not an issue. But if you distribute your plugins, you should pay attention to their compatibility.

[[sec:gradle_api]]
=== The Gradle API

All plugins use the https://docs.gradle.org/current/javadoc/index.html[Gradle Core API] to configure a Gradle build. The Gradle API must be added as a build compile-time dependency using the helper function `gradleApi()`

[source,kotlin]
----
dependencies {
    compileOnly(gradleApi())
}
----

TIP: `gradleApi()` must be a `compileOnly` dependency, because the correct Gradle API will be provided by Gradle at runtime.

==== Version of the Gradle API Version

The Gradle API version provided by `gradleApi()` is the same as the version of Gradle used to build the plugin.

For example, if the plugin is built using Gradle version 7.6.1, then `gradleApi()` also be version 7.6.1. If the plugin is later built with Gradle {gradleVersion}, then the `gradleApi()` will change to be version {gradleVersion}.

This implicit link affects the Gradle versions your plugin supports. It's easy to build a plugin using one version of Gradle that has functions or classes that are not present in other versions of Gradle.

This might result in runtime exceptions, such as `NoSuchMethodError`, if a plugin uses a functionality of the Gradle API that is missing in the Gradle being used to run the plugin. This might happen the plugin is run by an older Gradle version that is missing a function or class, _or_ if the plugin uses a function or class that has been removed in newer versions (which can happen when using deprecated or internal Gradle features).

Supporting different versions of Gradle can be tested using https://docs.gradle.org/current/userguide/test_kit.html#sub:gradle-runner-gradle-version[TestKit].

[[sec:redistributed_gradle_api]]
=== Redistributed Gradle API

To avoid the implicit link on a Gradle version that comes with using `gradleApi()`, an alternative is to use the https://docs.nokee.dev/manual/gradle-plugin-development.html[Nokee redistributed Gradle API artifacts]. 
These are like `gradleApi()`, except they allow specifying a specific version of the Gradle API.

[subs="attributes"]
[source,kotlin]
----
dependencies {
    compileOnly("dev.gradleplugins:gradle-api:{gradleVersion}")
}
----

TIP: Because it is provided by Gradle at runtime, `gradle-api` must be a `compileOnly` dependency.

This makes the version of the Gradle API being used to build the plugin more explicit, removing the ambiguity avoids the implicit link between `gradleApi()` and the build version of Gradle.

On the other hand, you cannot use newer APIs if your plugin is running on a recent version of Gradle.

[[sec:gradle_kotlin_dsl]]
=== gradleKotlinDsl()

[source,kotlin]
----
dependencies {
    compileOnly(gradleKotlinDsl())
}
----

The `gradleKotlinDsl()` contains helpers to work better with Kotlin.

For example:

* `tasks.withType<Jar> {}` (instead of `tasks.withType(Jar::class.java) {}`)
* `val commonMain by getting {}` (instead of `getByName("commonMain") {}`)
* `"implementation"("group:artifact:version")` (instead of `add("implementation", "group:artifact:version")`)
* Even `gradleKotlinDsl()` is provided by `gradleKotlinDsl()` !

You can use optionally it to build your plugins, but it's not mandatory.

It is part of the Gradle distribution. You will find it under `~/.gradle/wrapper/dists/gradle-$version-bin/$sha/gradle-$version/lib/gradle-kotlin-dsl-$version.jar`.

When writing `build.gradle.kts`, `gradleKotlinDsl()` is in the classpath and provide helpers to work better with Kotlin.

TIP: Because it is provided by Gradle at runtime, `gradleKotlinDsl()` must be a `compileOnly` dependency.

[[sec:kotlin_stdlib]]
=== kotlin-stdlib

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-stdlib:$version")
}
----

The Kotlin compatibility matrix can be found in the https://docs.gradle.org/current/userguide/compatibility.html#kotlin[Gradle compatibility page]. If you want your plugin to be compatible with a given version of Gradle, you need to make sure to use a compatible version of kotlin-stdlib. For an example, if you need your plugin to be compatible with Gradle 7.0, you cannot use any Kotlin 1.5 only API (like https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/lowercase.htmllowercase) and need to compile against `kotlin-stdlib:1.4.31`.

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-stdlib:1.4.31")
}
----

For similar reasons, any transitive dependency of your plugin needs to use a `kotlin-stdlib` version compatible with the Gradle one. While you can ensure that at compile time for your own code, it's often more complicated for dependencies so make sure to test your plugins and/or double check your transitive dependencies.

Note: The `kotlin-stdlib` version is independent of your Kotlin Gradle Plugin version. You can use a newer Kotlin Gradle Plugin version with an older `kotlin-stdlib` using the https://kotlinlang.org/docs/compiler-reference.html#api-version-version[`apiVersion`] compiler argument.

TIP: Because it is provided by Gradle at runtime, `kotlin-stdlib` must be a `compileOnly` dependency.

[[sec:kotlin_reflect]]
=== kotlin-reflect

[source,kotlin]
----
dependencies {
    compileOnly("org.jetbrains.kotlin:kotlin-reflect:$version")
}
----

Not all plugins need `kotlin-reflect` but if yours does, the situation is the same as for `kotlin-stdlib`. `kotlin-reflect` needs to be compatible with the https://docs.gradle.org/current/userguide/compatibility.html#kotlin[target Gradle version]

TIP: Because it is provided by Gradle at runtime, `gradle-api` must be a `compileOnly` dependency.

[[sec:others]]
=== others (`implementation` or `api`)

You can add other non-compileOnly dependencies like in other JVM projects:

[source,kotlin]
----
dependencies {
    // Kotlin dependencies
    // ⚠️ make sure they do not depend on an incompatible version of kotlin-stdlib
    implementation("com.squareup:kotlinpoet:1.12.0")

    // Java dependencies
    implementation("asm:asm:3.3.1")
}
----

These dependencies are not provided by Gradle at runtime and should use the `implementation` configuration (or `api` if part of your plugin API). Because Gradle may load different plugins with conflicting dependencies in the same https://dev.to/autonomousapps/build-compile-run-a-crash-course-in-classpaths-f4g[classloader], your plugin users may experience crashes if symbols are incompatible or missing. To mitigate those, you can relocate your dependencies.

[[sec:compiler_options]]
== Different compiler configurations

You can choose different options to either improve the developer experience of writing plugins and/or improve compatibility with Gradle and Java in general.

[[sec:sam_with_receiver]]
=== `sam-with-receiver` compiler plugin

Gradle comes with the https://docs.gradle.org/current/javadoc/org/gradle/api/HasImplicitReceiver.html[@HasImplicitReceiver] annotation. When used in conjunction with Kotlin https://kotlinlang.org/docs/sam-with-receiver-plugin.html[sam-with-receiver compiler plugin], it can turn the parameter of https://kotlinlang.org/docs/fun-interfaces.html[Single Abstract Method (SAM)] interfaces like https://docs.gradle.org/current/javadoc/org/gradle/api/Action.html[Action] into implicit receiver making your code look more like a DSL:

[source,kotlin]
----
// Without sam-with-receiver
tasks.register("hello") { task ->
    // You need to use the lambda parameter
    task.doLast {
        println("Hello World")
    }
}

// With sam-with-receiver
tasks.register("hello") {
    // You can use the receiver
    doLast {
        println("Hello World")
    }
}
----

The latter looks closer to `build.gradle.kts` scripts and more concise but is more prone to scoping errors as well.


[[sec:kotlin_assignment]]
=== `kotlin-assignment` compiler plugin

The `kotlin-assignment` compiler plugin is still experimental. It allows overriding assignments so that Kotlin callers do not have to call `.set()` on https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html[Property]:


----
// Without kotlin-asignment
tasks.jar.configure {
    // You need to call .set()
    archiveBaseName.set("mylib")
}

// With kotlin-asignment
tasks.jar.configure {
    // No need to call .set()
    archiveBaseName = "mylib"
}
----

[[sec:api_version]]
=== `apiVersion` compiler option

The https://kotlinlang.org/docs/compiler-reference.html#api-version-version[Kotlin compiler apiVersion option] enforces that the generated bytecode only uses declaration from the given version. This is important to stay compatible with the Kotlin version embedded by Gradle.

Note: while this enforces your code is compatible with a given version of Kotlin stdlib and Gradle, it does not check dependencies, so it is important to check your dependencies are also compatible.

[[sec:sam_conversion_class]]
=== `-Xsam-conversions=class` compiler option

`-Xsam-conversions=class` sets up the implementation strategy for SAM (single abstract method) conversion to always generate anonymous classes, instead of using the `invokedynamic` JVM instruction. This is to make sure the lambdas are serializable and provide a better support for configuration cache and incremental build. This is particularly important for lambdas used from `doLast:
See https://github.com/gradle/gradle/issues/17052[Issue #17052] for more information.

[source,kotlin]
----
// Without `-Xsam-conversions=class` task will never be up-to-date
task.doLast {
    // Something
}
----


[[sec:plugins_for_your_plugins]]
== Different development plugins

In order to configure all the above options and more, Gradle offers several plugins:

* `"java-gradle-plugin"`
* `kotlin("jvm")` (id `"org.jetbrains.kotlin.jvm"`)
* `embedded-kotlin` (id `"org.gradle.kotlin.embedded-kotlin"`))
* `kotlin-dsl` (id `"org.gradle.kotlin.kotlin-dsl"`)

Usually you would choose one of those combinations:

* `"java-gradle-plugin"` and `kotlin("jvm")`
* `"java-gradle-plugin"` and `embedded-kotlin`
* `kotlin-dsl`

Let's see what each plugin is doing.

[[sec:java_gradle_plugin]]
=== The `"java-gradle-plugin"` plugin (built-in)

`"java-gradle-plugin"` amongst other things:

* applies the <<java_library_plugin.adoc#java_library_plugin,Java Library (`java-library`)>> plugin
* adds the `gradlePlugin {}` extension and generates the resource files matching your plugin id with its implementation class
* adds the `gradleApi()` dependency to the `api` configuration
* performs validation of plugin metadata during `jar` task execution.
* adds the `gradleTestKit()` dependency to the `testImplementation` configuration

You always want this plugin to develop custom Gradle plugins (although other plugins might apply it for you). Refer to the full <<java_gradle_plugin.adoc, documentation>> for more information.

[[sec:kotlin_jvm]]
=== The `kotlin("jvm")` plugin

`kotlin("jvm")` is the plugin that configures the Kotlin compiler amongst many other things.

You usually always want this plugin to develop custom Gradle plugins (although other plugins might apply it for you). Refer to the full https://kotlinlang.org/docs/gradle.html[documentation] for more information.

[[sec:embedded-kotlin]]
=== The `embedded-kotlin` plugin

`embedded-kotlin` is built on top of `kotlin("jvm")` and does the following:

* applies the `kotlin("jvm")` plugin using the same version as the Gradle embedded version
* adds `kotlin-stdlib` and `kotlin-reflect` to the `compileOnly` dependency

Use this plugin if you want to use the same Kotlin version to develop your plugins that the version used by your Gradle build. This is especially useful if you do not intend to distribute your plugins, for an example, for convention plugins.

[[sec:kotlin-dsl]]
=== The `kotlin-dsl` plugin

`kotlin-dsl` is built on top of `kotlin-embedded` and does the following:

* applies `"java-gradle-plugin"`
* applies `kotlin-embedded`
* applies the `kotlin-dsl-precompiled-script-plugins` allowing to use `build.gradle.kts` files
* adds `gradleKotlinDsl()` to the `compileOnly` configuration
* configures the `sam-with-receiver` Kotlin compiler plugin
* configures the `kotlin-assignment` Kotlin compiler plugin
* sets `apiVersion` and `languageVersion` to the Kotlin embedded version
* adds the `-Xsam-conversions=class` compiler option
* adds others compiler options for compatibility:
** `-java-parameters` to support https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html[Java 8 Parameter] class and getting method parameters through reflection
** `-Xjvm-default=all` to add link:https://kotlinlang.org/docs/java-to-kotlin-interop.html#default-methods-in-interfaces[Default methods in interfaces]
** `-Xjsr305=strict` for https://kotlinlang.org/docs/java-interop.html#compiler-configuration[increased null safety]


The `kotlin-dsl` plugin is the-all-in-one plugin. By applying the `kotlin-dsl-precompiled-script-plugins` and the same options as Gradle when compiling scripts, it allows you to write plugin like you would write scripts, using `.gradle.kts` file.

Like the `embedded-kotlin` plugin, it uses the same Kotlin version as your Gradle build. This is useful if you do not intend to distribute your plugins, for an example, for convention plugins. If you need to distribute your plugin, make sure to use a Kotlin version that is compatible with the Gradle version you are targetting


[[sec:your_public_api]]
== Plugin API compatibility

In order to make your plugin API compatible with Groovy, avoid relying on Kotlin specific features so that the developer experience is as good for Groovy scripts as for Kotlin scripts. For an example the Kotlin compiler emits https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/ReadMe.md[metadata] that only the Kotlin compiler can understand for features like default parameters or extension function. It is OK to use those to provide a better experience for Kotlin scripts as long as same functionality is accessible through other means in Groovy.

In general, relying on link:{kotlin-reference}java-interop.html[calling Java from Kotlin recommendations] and link:{kotlin-reference}java-to-kotlin-interop.html[calling Kotlin from Java recommendations] works well for Groovy too.

[[sec:action]]
`Action`

Do not use Kotlin function types in your API. Groovy doesn't know about Kotlin anything about. Groovy uses Closures.

Instead, use an `Action<T>` parameter. Decorated Gradle objects contain an overload for every function that takes an `Action<T>` parameter:

[source,kotlin]
----
class Something

abstract class MyExtension {
    // Use Action<T> in your APIs
    // Gradle will generate an overload at runtime that takes a Groovy Closure
    fun doSomething(action: Action<Something>) {
        //
    }
}
----

In order for the overload to be generated, the object must be constructed by Gradle. For an example:

[source,kotlin]
----
abstract class MyPlugin: Plugin<Project> {
  override fun apply(project: Project) {
    project.extensions.create("myExtension", MyExtension::class.java)
  }
}
----
