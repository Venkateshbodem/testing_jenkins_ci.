// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[five_things]]
= Five things you need to know about Gradle

Gradle is a flexible and powerful build tool that can easily feel intimidating when you start to learn it. There is potentially a lot to learn. However, there are some core principles that will make it easier to learn how to use Gradle effectively once you understand them. We present those principles here.

== 1. Gradle is a general-purpose build tool

Gradle allows you to build any software, because it makes few assumptions about what you're trying to build or how it should be done. The most notable restriction is that dependency management currently only supports Maven- and Ivy-compatible repositories and the filesystem.

This doesn't mean you have to do a lot of work to create a build. Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through <<plugins#plugins,_plugins_>>. You can even create and publish custom plugins to encapsulate your own conventions and build functionality.

== 2. The core model is based on a network of tasks

Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them.

This diagram shows two example task graphs, one abstract and the other concrete, with the dependencies between the tasks represented as arrows:

.Two examples of a Gradle task graph
image::task-dag-examples.png[Example task graphs]

Almost any build process can be modeled as a graph of tasks in this way, which is one of the reasons why Gradle is so flexible.

Tasks themselves consist of:

 * Actions — pieces of work that do something, like copy files or compile source
 * Inputs — values, files and directories that the actions use or operate on
 * Outputs — files and directories that the actions modify or generate

In fact, all of the above are optional depending on what the task needs to do. Some tasks — such as the <<base_plugin#sec:base_tasks,standard lifecycle tasks>> — don't even have any actions. They simply aggregate multiple tasks together as a convenience.

NOTE: You choose which task to run. Save time by specifying the task that does what you need, but no more than that. If you just want to run the unit tests, choose the task that does that — typically `test`. If you want to package an application, most builds have an `assemble` task for that.

One way to customize a build is to add extra steps to it. This is easy to do in Gradle: define your own tasks and insert them into the task graph via the <<tutorial_using_tasks#sec:task_dependencies,task dependency mechanism>>. You can have your tasks depend on any other task or configure existing tasks to depend on yours. The main restriction is that you cannot create any circular dependencies within the task graph.

One last thing: Gradle's <<more_about_tasks#sec:up_to_date_checks,incremental build>> support is robust and reliable, so keep your builds running fast by avoiding the `clean` task unless you actually do want to perform a clean. 

== 3. Gradle has distinct build phases

It's important to understand that Gradle evaluates and executes build scripts in three phases:

 1. Initialization
 2. Configuration
 3. Execution

In well-designed build scripts, the vast majority of what you see is evaluated during the configuration phase. Even so, some elements are likely to be evaluated during the execution phase, particularly the contents of `doLast {}` and `doFirst {}` blocks.

NOTE: Gradle's build phases are not like Maven's phases. Maven uses its phases to divide the build execution into multiple stages. They serve a similar role to Gradle's task graph, although less flexibly.

When you are authoring or modifying a build, it's important to recognize which bits are evaluated during which phases. Otherwise you will end up with a build that doesn't work as expected. For example, if you set a property within the execution phase, any part of the build that reads that property during the configuration phase won't see the new value.

Consider the following (contrived) example that attempts to initialise a `Copy` task from a properties file. You might try this if the properties file is generated by another task. The problem is that `into` must be set during the configuration phase, otherwise the task won't run. Setting the value within a `doFirst {}` block fails as it happens too late.

[source,groovy]
.Configuring a task within an action (execution phase) won't work
----
task copyFiles(type: Copy) {
    doFirst {
        into new Properties().load("my-props.properties").     // <1>
                getProperty("notes.output.dir")                // <1>
    }
    from file("notes")                                         // <2>
    include "**/*.txt"
}
----
<1> Evaluated during _execution_ phase
<2> Evaluated during _configuration_ phase

This used to be more of a problem when the `<<` syntax for defining a task was more common, as it implicitly declared a task action — something that is evaluated/run during the execution phase. Users would often attempt to configure the task within that definition and wonder why it wasn't working.

As a general rule of thumb, everything in a build script happens during the configuration phase unless it defines a task action. There are some other exceptions, such as link:{javadocPath}/org/gradle/api/execution/TaskExecutionGraph.html#whenReady-org.gradle.api.Action-[TaskExecutionGraph.whenReady(Action)], but the documentation is clear on their behavior.

You can learn more in the <<build_lifecycle#build_lifecycle,Build Lifecycle>> chapter.

== 4. Gradle is extensible in more ways than one

It would be great if you could build your project using only the build logic bundled with Gradle, but that's rarely possible. Most builds have some special requirements that mean you need to add custom build logic.

Gradle provides several mechanisms that allow you to extend it, from the very simple to the very powerful:

 1. Extra properties on <<writing_build_scripts#sec:extra_properties,projects>> and <<writing_build_scripts#sec:extra_task_properties,tasks>>.
+
These allows you to add your own properties to a project or task that you can then use from your own custom actions or any other build logic. Extra properties can even be applied to tasks that aren't explicitly created by you, such as those created by Gradle's core plugins.

 2. Custom task actions.
+
You can attach custom build logic that executes before or after a task via the link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doFirst(org.gradle.api.Action)[Task.doFirst()] and link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)[Task.doLast()] methods.

 3. <<custom_tasks,Custom task types>>.
+
When you want the build to do some work that an existing task can't do, you can simply write your own task type. It's typically best to put the source file for a custom task type in the <<organizing_gradle_projects#sec:build_sources,_buildSrc_>> directory or in a packaged plugin. Then you can use the custom task type just like any of the Gradle-provided ones.

 4. Custom conventions.
+
Conventions are a powerful way to simplify builds so that users can understand and use them more easily. This can be seen with builds that use standard project structures and naming conventions, such as <<building_java_projects#building_java_projects,Java builds>>. You can write your own plugins that provide conventions — they just need to configure default values for the relevant aspects of a build.

 5. {guidesUrl}/implementing-gradle-plugins/#modeling_dsl_like_apis[A custom model].
+
Gradle allows you to introduce new concepts into a build beyond tasks, files and dependency configurations. You can see this with most language plugins, which add the concept of <<building_java_projects#sec:java_source_sets,_source sets_>> to a build. Appropriate modeling of a build process can greatly improve a build's ease of use and its efficiency. But new model elements should be used sparingly to avoid complex and incomprehensible builds.


== 5. Build scripts operate against an API

It's easy to view Gradle's build scripts as executable code, because that's what they are. But that's an implementation detail: well-designed build scripts describe _what_ steps are needed to build the software, not _how_ those steps should do the work. That's a job for custom task types and plugins.

Yet there is one area in which it is useful to view a build script as executable code: in understanding how the syntax of the build script maps to Gradle's API. The API documentation — formed of the link:{groovyDslPath}/[Groovy DSL Reference] and the link:{javadocPath}/[Javadocs] — lists methods and properties, and refers to closures and actions. What do these mean within the context of a build script?

Check out the <<groovy_build_script_primer#groovy_build_script_primer,Groovy Build Script Primer>> to learn the answer to that question and make effective use of the API documentation.

NOTE: As Gradle runs on the JVM, build scripts can also use the standard {javaApi}[Java API]. Groovy build scripts can additionally use the Groovy APIs, while Kotlin build scripts can use the Kotlin ones.



