// Copyright 2023 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[tutorial_using_tasks]]
= Tasks Basics

The work that Gradle can do on a project is defined by one or more _tasks_.

image::author-gradle-1.png[]

A task represents some atomic piece of work that a build performs.
This might be compiling some classes, creating a JAR, generating Javadoc, or publishing some archives to a repository.

You run a Gradle build using the `gradle` command or by invoking the Gradle Wrapper (`./gradlew' or `gradle.bat`) in your project directory.

As part of the build process, Gradle finds all the tasks in your project coded in plugins or build scripts.

[[sec:hello_world]]
== Hello world

Let's take a look at a simple "Hello World" task in a build script:

====
include::sample[dir="snippets/tutorial/hello/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/hello/groovy", files="build.gradle[]"]
====

You can execute the build script with `./gradlew -q hello`:

====
----
$ ./gradlew -q hello
include::{snippetsPath}/tutorial/hello/tests/hello.out[]
----
====

[TIP]
====
The `-q` option suppresses Gradle's log messages, so only the tasks' output is shown.
====

In the example, the build script defines a single task called `hello`, and adds an action.

When you run `./gradlew hello`, Gradle executes the `hello` task, which executes the action you've provided.
The action is simply a block containing some code to execute: `println("Hello world!")`.

== Available tasks

Even if your build script is empty, Gradle provides several default tasks for a project, which are listed by running `./gradlew tasks`:

[source]
----
------------------------------------------------------------
Tasks runnable from root project 'myTutorial'
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'myTutorial'.
...
----

Once we apply a plugin to our project, such as the `application` plugin, the default tasks available include:

[source]
----
Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.

...

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

...

Other tasks
-----------
compileJava - Compiles main Java source.

...
----

This is because the `application` plugin code contains additional tasks now available in your project.

== Task types

Two types of tasks can be executed:

1. *Actionable tasks* have some action(s) attached to do work in your build: `compileJava`.
2. *Lifecycle tasks* are workflow tasks with no actions attached: `assemble`, `build`.

== Built-in tasks

Gradle provides many built-in tasks with common and popular functionality, such as copying or deleting files.

This example task copies `*.war` files from the `source` directory to the `target` directory using the `Copy` built-in task:

[source]
----
tasks.register("copyTask",Copy) {
    from("source")
    into("target")
    include("*.war")
}
----

[[sec:task_dependencies]]
== Task dependencies

You can declare tasks that depend on other tasks:

====
include::sample[dir="snippets/tutorial/intro/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/intro/groovy", files="build.gradle[]"]

----
$ gradle -q intro
include::{snippetsPath}/tutorial/intro/tests/intro.out[]
----
====

To add a dependency, the corresponding task does not need to exist:

====
include::sample[dir="snippets/tutorial/lazyDependsOn/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/lazyDependsOn/groovy", files="build.gradle[]"]

----
$ gradle -q taskX
include::{snippetsPath}/tutorial/lazyDependsOn/tests/lazyDependsOn.out[]
----
====

The dependency of `taskX` to `taskY` may be declared before `taskY` is defined.

[[sec:dynamic_tasks]]
== Flexible task registration

The capabilities of the Groovy or Kotlin language can be used in a task.

As an example, you can register multiple tasks of the same type in a loop:

====
include::sample[dir="snippets/tutorial/dynamic/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/dynamic/groovy", files="build.gradle[]"]

----
$ gradle -q task1
include::{snippetsPath}/tutorial/dynamic/tests/dynamic.out[]
----
====

[[sec:manipulating_existing_tasks]]
== Manipulating existing tasks

Once tasks are registered, they can be accessed via an _API_.

For instance, you can use this to dynamically add dependencies to a task, at runtime:

====
include::sample[dir="snippets/tutorial/dynamicDepends/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/dynamicDepends/groovy", files="build.gradle[]"]

----
$ gradle -q task0
include::{snippetsPath}/tutorial/dynamicDepends/tests/dynamicDepends.out[]
----
====

Or you can add behavior to an existing task:

====
include::sample[dir="snippets/tutorial/helloEnhanced/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/helloEnhanced/groovy", files="build.gradle[]"]

----
$ gradle -q hello
include::{snippetsPath}/tutorial/helloEnhanced/tests/helloEnhanced.out[]
----
====

The calls `doFirst` and `doLast` can be executed multiple times.
They add an action to the beginning or the end of the task's actions list.
When the task executes, the actions in the action list are executed in order.

[[sec:using_methods]]

[[sec:default_tasks]]
== Default tasks

Gradle allows you to define one or more default tasks that are executed if no other tasks are specified:

====
include::sample[dir="snippets/tutorial/defaultTasks/kotlin", files="build.gradle.kts[]"]
include::sample[dir="snippets/tutorial/defaultTasks/groovy", files="build.gradle[]"]

----
$ gradle -q
include::{snippetsPath}/tutorial/defaultTasks/tests/defaultTasks.out[]
----
====

This is equivalent to running `gradle clean run`.
If a subproject does not specify default tasks, the default tasks of the parent project are used (if defined).
