// Copyright 2018 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[gradle_overview]]
[[what_is_gradle]]
= What is Gradle?

Gradle is an open-source https://en.wikipedia.org/wiki/Build_automation[build automation] tool flexible enough to build almost any type of software.
This flexibility is the result of Gradle making few assumptions about what you're trying to build or how to build it.
Gradle bases its design on the following fundamentals:

High performance::
Gradle avoids unnecessary work by only running tasks that need to do work because inputs or outputs have changed.
Gradle uses various caches to reuse outputs from previous builds.
With a shared build cache, you can even reuse outputs from other machines.
JVM foundation::
Gradle runs on the JVM. This is a bonus for users familiar with Java, since build logic can use the standard Java APIs.
It also makes it easy to run Gradle on different platforms.
Conventions::
Gradle makes common types of projects easy to build through conventions. Plugins set sensible defaults to keep build scripts minimal.
But these conventions don't limit you: you can configure settings, add your own tasks, and make many other customizations in your builds.
Extensibility::
You can readily extend Gradle to provide your own build logic with custom tasks and plugins.
See Android builds for an example: they add many new build concepts such as flavors and build types.
IDE support::
Several major IDEs provide interaction with Gradle builds, including Android Studio, IntelliJ IDEA, Eclipse, VSCode, and NetBeans.
Gradle can also generate the solution files required to load a project into Visual Studio.
Insight::
https://scans.gradle.com/[Build Scanâ„¢] provides extensive information about a build that you can use to identify issues.
You can use Build Scans to identify problems with a build's performance and even share them for debugging help.

== Concepts

It's helpful to know the following concepts before you dive into the details of Gradle.

=== Projects

Projects are the things that Gradle builds.
Projects contain a build script, which is a file located in the project's root directory named `build.gradle` or `build.gradle.kts`.
Builds scripts define tasks, dependencies, plugins, and other configuration for that project.
A single build can contain one or more projects and each project can contain their own subprojects.

=== Tasks

Tasks contain the logic that implements builds.
In most use cases, you'll use or extend existing tasks, like the built-in Java `test` task.
Gradle provides tasks that implement many common build system goals, like running tests and creating archives.
Plugins provide even more types of tasks.

Tasks themselves consist of:

 * Actions: pieces of work that do something, like copy files or compile source
 * Inputs: values, files and directories that the actions use or operate on
 * Outputs: files and directories that the actions modify or generate

=== Plugins

Plugins provide a means of reusing logic and configuration across multiple projects.
With plugins, you can write a task once and use it in multiple builds. Or you can store common configuration,
like logging, dependencies, and version management, in one place. This reduces duplication in
build scripts.

=== Build Phases

Gradle evaluates and executes build scripts in three *build phases* of the <<build_lifecycle#build_lifecycle,Build Lifecycle>>:

Initialization::
Sets up the environment for the build and determine which projects will take part in it.

Configuration::
Constructs and configures the task graph for the build. Determines which tasks need to run and in which order, based on the task the user wants to run.

Execution::
Runs the tasks selected at the end of the configuration phase.

=== Builds

A build is an execution of a collection of tasks in a Gradle project. You run a build via the CLI or an IDE by specifying task selectors. Gradle configures the build and selects the tasks to run. Gradle runs the smallest complete set of tasks required from the requested tasks and their dependencies.

== Optimizations

Over the years, Gradle has engineered a number of ways to make your builds faster.
Gradle enables some of these, like the Daemon, by default. You must explicitly enable some other optimizations
through configuration or build logic. This section highlights some of the most important
optimizations to know about when you start using Gradle.

=== Configuration Cache

The configuration phase is a large up-front cost for all Gradle builds. Every time you build your project, Gradle
configures the project based on available inputs like build scripts, settings, and system properties. The
configuration cache allows Gradle to cache the result of this configuration. This can save significant time
in every build. However, the configuration cache is only compatible with certain syntax.

=== Build Cache

When you run Gradle with the build cache enabled, Gradle calculates a cache key for the inputs for each
task. If the build cache already contains the outputs for that key, Gradle reuses those outputs immediately without re-running the task.
Enabling the build cache can speed up builds significantly by pulling data from the cache instead of running the same task repeatedly.

=== Script Design

Well-designed build scripts consist mostly of
<<authoring_maintainable_build_scripts#sec:avoid_imperative_logic_in_scripts,declarative configuration, rather than imperative logic>>.
That configuration runs during the configuration phase.
Many builds also register instances of custom task types providing additional actions that run during the execution phase.

It's easy to view Gradle's build scripts as executable code, because that's what they are.
But that's an implementation detail: well-designed build scripts describe _what_ steps build the software,
not _how_ those steps do the work. That's a job for custom task types and plugins.
