// Copyright 2022 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

= Configure Plugins

[[sec:getting_input_from_the_build]]
== Making the plugin configurable

Most plugins offer some configuration options for build scripts and other plugins to use to customize how the plugin works. Plugins do this using _extension objects_.
The Gradle link:{groovyDslPath}/org.gradle.api.Project.html[Project] has an associated link:{javadocPath}/org/gradle/api/plugins/ExtensionContainer.html[ExtensionContainer] object
that contains all the settings and properties for the plugins that have been applied to the project.
You can provide configuration for your plugin by adding an extension object to this container.
An extension object is simply an object with Java Bean properties that represent the configuration.

Let's add a simple extension object to the project. Here we add a `greeting` extension object to the project, which allows you to configure the greeting.

.A custom plugin extension
====
include::sample[dir="snippets/customPlugins/customPluginWithConvention/groovy",files="build.gradle[]"]
include::sample[dir="snippets/customPlugins/customPluginWithConvention/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/customPlugins/customPluginWithConvention/tests/customPluginWithConvention.out[]
----

In this example, `GreetingPluginExtension` is an object with a property called `message`. The extension object is added to the project with the name `greeting`.
This object then becomes available as a project property with the same name as the extension object.

Oftentimes, you have several related properties you need to specify on a single plugin. Gradle adds a configuration block for each extension object, so you can group settings together.
The following example shows you how this works.

.A custom plugin with configuration block
====
include::sample[dir="snippets/customPlugins/customPluginWithAdvancedConvention/groovy",files="build.gradle[]"]
include::sample[dir="snippets/customPlugins/customPluginWithAdvancedConvention/kotlin",files="build.gradle.kts[]"]
====

.Output of **`gradle -q hello`**
----
> gradle -q hello
include::{snippetsPath}/customPlugins/customPluginWithAdvancedConvention/tests/customPluginWithAdvancedConvention.out[]
----

[.multi-language-text.lang-groovy]
In this example, several settings can be grouped together within the `greeting` closure. The name of the closure block in the build script (`greeting`) needs to match the extension object name.
Then, when the closure is executed, the fields on the extension object will be mapped to the variables within the closure based on the standard Groovy closure delegate feature.

[.multi-language-text.lang-kotlin]
In this example, several settings can be grouped together within the `configure<GreetingPluginExtension>` block.
The type used on the `configure` function in the build script (`GreetingPluginExtension`) needs to match the extension type.
Then, when the block is executed, the receiver of the block is the extension.

In this way, using an extension object _extends_ the Gradle DSL to add a project property and DSL block for the plugin.
And because an extension object is simply a regular object, you can provide your own DSL nested inside the plugin block by adding properties and methods to the extension object.

=== Developing project extensions

You can find out more about implementing project extensions in <<custom_gradle_types.adoc#custom_gradle_types,Developing Custom Gradle Types>>.


[[sec:working_with_files_in_custom_tasks_and_plugins]]
== Working with files in custom tasks and plugins

When developing custom tasks and plugins, it's a good idea to be very flexible when accepting input configuration for file locations.
You should use Gradle's <<custom_gradle_types.adoc#managed_properties,managed properties>> and `project.layout` to select file or directory locations.
By this, the actual location will only be resolved when the file is needed and can be reconfigured at any time during build configuration.

.Evaluating file properties lazily
====
include::sample[dir="snippets/tasks/customTaskWithFileProperty/groovy",files="build.gradle[tags=all]"]
include::sample[dir="snippets/tasks/customTaskWithFileProperty/kotlin",files="build.gradle.kts[tags=all]"]
====

.Output of **`gradle -q sayGreeting`**
----
> gradle -q sayGreeting
include::{snippetsPath}/tasks/customTaskWithFileProperty/tests/lazyFileProperties.out[]
----

In this example, we configure the `greet` task `destination` property as a closure/provider, which is evaluated with
the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] method to turn the return value of the closure/provider
into a `File` object at the last minute. You will notice that in the example above we specify the `greetingFile` property value after we have configured to use it for the task.
This kind of lazy evaluation is a key benefit of accepting any value when setting a file property, then resolving that value when reading the property.


[[sec:mapping_extension_properties_to_task_properties]]
== Mapping extension properties to task properties

Capturing user input from the build script through an extension and mapping it to input/output properties of a custom task is a useful pattern.
The build script author interacts only with the DSL defined by the extension. The imperative logic is hidden in the plugin implementation.

Gradle provides some types that you can use in task implementations and extensions to help you with this. Refer to <<lazy_configuration.adoc#lazy_configuration,Lazy Configuration>> for more information.

[[sec:custom_plugins_standalone_project]]
== A standalone project

Now we will move our plugin to a standalone project so that we can publish it and share it with others. This project is simply a Java project that produces a JAR containing the plugin classes.
The easiest and the recommended way to package and publish a plugin is to use the <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle Plugin Development Plugin>>.
This plugin will automatically apply the <<java_plugin.adoc#java_plugin,Java Plugin>>, add the `gradleApi()` dependency to the api configuration,
generate the required plugin descriptors in the resulting JAR file and configure the <<plugins.adoc#sec:plugin_markers,Plugin Marker Artifact>> to be used when publishing.
Here is a simple build script for the project.

.A build for a custom plugin
====
include::sample[dir="snippets/plugins/customPlugin/groovy/java-gradle-plugin",files="build.gradle[tags=use-and-configure-plugin]"]
include::sample[dir="snippets/plugins/customPlugin/kotlin/java-gradle-plugin",files="build.gradle.kts[tags=use-and-configure-plugin]"]
====


[[capturing_user_input_to_configure_plugin_runtime_behavior]]
== Capturing user input to configure plugin runtime behavior

Plugins often times come with default conventions that make sensible assumptions about the consuming project.
The Java plugin, for example, searches for Java source files in the directory `src/main/java`.
Default conventions are helpful to streamline project layouts but fall short when dealing with custom project structures, legacy project requirements or a different user preference.

Plugins should expose a way to reconfigure the default runtime behavior.
The section <<writing-and-using-custom-task-types,Prefer writing and using custom task types>> describes one way to achieve configurability: by declaring setter methods for task properties.
The more sophisticated solution to the problem is to expose an extension.
An extension captures user input through a custom DSL that fully blends into the DSL exposed by Gradle core.

The following example applies a plugin that exposes an extension with the name `binaryRepo` to capture a server URL:

====
include::sample[dir="snippets/developingPlugins/customTask/groovy",files="build.gradle[tags=plugin-extension]"]
include::sample[dir="snippets/developingPlugins/customTask/kotlin",files="build.gradle.kts[tags=plugin-extension]"]
====

Let's assume that you'll also want to do something with the value of `serverUrl` once captured.
In many cases the exposed extension property is directly mapped to a task property that actually uses the value when performing work.
To avoid evaluation order problems you should use <<lazy_configuration#lazy_properties,the public API `Property`>> which was introduced in Gradle 4.0.

Let's have a look at the internals of the plugin `BinaryRepositoryVersionPlugin` to give you a better idea.
The plugin creates the extension of type `BinaryRepositoryExtension` and maps the extension property `serverUrl` to the task property `serverUrl.`

.BinaryRepositoryVersionPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/customTask/groovy/buildSrc/src/main/java/org/myorg/BinaryRepositoryVersionPlugin.java[]
----

Instead of using a plain `String` type, the extension defines the properties `coordinates` and `serverUrl` with type `Property<String>`.
The abstract getters for the properties are automatically initialized by Gradle.
The values of a property can then be changed on the property object obtained through the corresponding getter method.

NOTE: The Gradle classloader automatically injects setter methods alongside all getter methods with the return type `Property`.
It allows developers to simplify code like `obj.prop.set 'foo'` to `obj.prop = 'foo'` in the Groovy DSL.

.BinaryRepositoryExtension.java
[source,java]
----
include::{snippetsPath}/developingPlugins/customTask/groovy/buildSrc/src/main/java/org/myorg/BinaryRepositoryExtension.java[]
----

The task property also defines the `serverUrl` with type `Property`.
It allows for mapping the state of the property without actually accessing its value until needed for processing - that is in the task action.

.LatestArtifactVersion.java
[source,java]
----
include::{snippetsPath}/developingPlugins/customTask/groovy/buildSrc/src/main/java/org/myorg/LatestArtifactVersion.java[]
----

NOTE: We encourage plugin developers to migrate their plugins to the public property API as soon as possible.
Plugins that are not based on Gradle 4.0 yet may continue to use the internal "convention mapping" API.
Please be aware that the "convention mapping" API is undocumented and might be removed with later versions of Gradle.

== Declaring a DSL configuration container

Sometimes you might want to expose a way for users to define multiple, named data objects of the same type.
Let's consider the following build script for illustration purposes.

====
include::sample[dir="snippets/developingPlugins/namedDomainObjectContainer/groovy",files="build.gradle[]"]
include::sample[dir="snippets/developingPlugins/namedDomainObjectContainer/kotlin",files="build.gradle.kts[]"]
====

The DSL exposed by the plugin exposes a _container_ for defining a set of environments.
Each environment configured by the user has an arbitrary but declarative name and is represented with its own DSL configuration block.
The example above instantiates a development, staging and production environment including its respective URL.

Obviously, each of these environments needs to have a data representation in code to capture the values.
The name of an environment is immutable and can be passed in as constructor parameter.
At the moment the only other parameter stored by the data object is an URL.
The POJO `ServerEnvironment` shown below fulfills those requirements.

.ServerEnvironment.java
[source,java]
----
include::{snippetsPath}/developingPlugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/org/myorg/ServerEnvironment.java[]
----

Gradle exposes the factory method
link:{javadocPath}/org/gradle/api/model/ObjectFactory.html#domainObjectContainer-java.lang.Class-org.gradle.api.NamedDomainObjectFactory-[ObjectFactory.domainObjectContainer(Class, NamedDomainObjectFactory)]
to create a container of data objects.
The parameter the method takes is the class representing the data.
The created instance of type link:{javadocPath}/org/gradle/api/NamedDomainObjectContainer.html[NamedDomainObjectContainer] can be exposed to the end user by adding it to the extension container with a specific name.

.ServerEnvironmentPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/namedDomainObjectContainer/groovy/buildSrc/src/main/java/org/myorg/ServerEnvironmentPlugin.java[]
----

It's very common for a plugin to post-process the captured values within the plugin implementation e.g. to configure tasks.
In the example above, a deployment task is created dynamically for every environment that was configured by the user.

== Reacting to plugins

Configuring the runtime behavior of existing plugins and tasks in a build is a common pattern in Gradle plugin implementations.
For example a plugin could assume that it is applied to a Java-based project and automatically reconfigure the standard source directory.

[[convention-api-usage-example]]
.InhouseStrongOpinionConventionJavaPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseStrongOpinionConventionJavaPlugin.java[]
----

The drawback to this approach is that it automatically forces the project to apply the Java plugin and therefore imposes a strong opinion on it.
In practice, the project applying the plugin might not even deal with Java code.
Instead of automatically applying the Java plugin the plugin could just react to the fact that the consuming project applies the Java plugin.
Only if that is the case then certain configuration is applied.

.InhouseConventionJavaPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseConventionJavaPlugin.java[]
----

Reacting to plugins should be preferred over blindly applying other plugins if there is not a good reason for assuming that the consuming project has the expected setup.
The same concept applies to task types.

.InhouseConventionWarPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/reactingToPlugins/groovy/buildSrc/src/main/java/InhouseConventionWarPlugin.java[]
----

== Providing default dependencies for plugins

The implementation of a plugin sometimes requires the use of an external dependency.
You might want to automatically download an artifact using Gradle’s dependency management mechanism and later use it in the action of a task type declared in the plugin.
Optimally, the plugin implementation doesn’t need to ask the user for the coordinates of that dependency - it can simply predefine a sensible default version.

Let’s have a look at an example.
You wrote a plugin that downloads files containing data for further processing.
The plugin implementation declares a custom configuration that allows for <<declaring_dependencies.adoc#declaring-dependencies,assigning those external dependencies with dependency coordinates>>.

.DataProcessingPlugin.java
[source,java]
----
include::{snippetsPath}/developingPlugins/defaultDependency/groovy/buildSrc/src/main/java/org/myorg/DataProcessingPlugin.java[]
----

.DataProcessing.java
[source,java]
----
include::{snippetsPath}/developingPlugins/defaultDependency/groovy/buildSrc/src/main/java/org/myorg/DataProcessing.java[]
----

Now, this approach is very convenient for the end user as there’s no need to actively declare a dependency.
The plugin already provides all the knowledge about this implementation detail.
But what if the user would like to redefine the default dependency.
No problem...the plugin also exposes the custom configuration that can be used to assign a different dependency.
Effectively, the default dependency is overwritten.

====
include::sample[dir="snippets/developingPlugins/defaultDependency/groovy",files="build.gradle[]"]
include::sample[dir="snippets/developingPlugins/defaultDependency/kotlin",files="build.gradle.kts[]"]
====

You will find that this pattern works well for tasks that require an external dependency when the action of the task is actually executed.
You can go further and abstract the version to be used for the external dependency by exposing an extension property (e.g.
`toolVersion` in link:{groovyDslPath}/org.gradle.testing.jacoco.plugins.JacocoPluginExtension.html[the JaCoCo plugin]).
